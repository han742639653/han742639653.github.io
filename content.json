{"meta":{"title":"荒凉院子","subtitle":"","description":"","author":"韩 亮","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"yolo系列笔记_1","slug":"yolo系列笔记-1","date":"2025-07-29T14:22:56.000Z","updated":"2025-07-30T02:11:11.933Z","comments":true,"path":"2025/07/29/yolo系列笔记-1/","link":"","permalink":"http://example.com/2025/07/29/yolo%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"1 yolo系列 Yolo 全称为 you only look once 即阅览一次就可识别出图像的物体的类别和位置。yolo模型是目标检测模型，而目标检测是计算机视觉中，在一张图像中找到某些特定的物体，目标检测不仅要求识别这些物体的种类，同时要求标出这些物体的位置。 yolo 属于one-stage（单阶段方法），即单次前向传播完成检测，无需显式生成候选区域，即 直接在图像中 密集网格或锚框上预测类别和位置，(Yolo,SSD,RetinaNet) 传统的Two-stage方法需要生成候选区域，对每个区域进行分类或回归（R-CNN，Faster R-CNN） 2 YoloV52.1 YoloV5 结构图 重新看yolov5代码 YOLOv5针对不同大小（n, s, m, l, x）的网络整体架构都是一样的，只不过会在每个子模块中采用不同的深度和宽度，除了n, s, m, l, x版本外还有n6, s6, m6, l6, x6，区别在于前者是针对更大分辨率的图片比如1280x1280,且结构上也有些差异，前者只会下采样到32倍且采用3个预测特征层 , 而后者会下采样64倍，采用4个预测特征层。 yolov5s为例 ，models/yolov5s.yaml。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253---yolov5s.yaml# Ultralytics 馃殌 AGPL-3.0 License - https://ultralytics.com/license# Parametersnc: 80 # number of classes 数据集中类别数depth_multiple: 0.33 # model depth multiple 模型层数因子（用来调整网络深度）width_multiple: 0.50 # layer channel multiple 决定整个模型中的深度（层数）和宽度anchors: #表示作用于当前特征图的Anchor大小XXX#9个anchor ，p表示特征图的层级 P3/8该层特征图缩放为1/8,是第3层特征，且[10,13],[16,30],[33,23]3个anchor - [10, 13, 16, 30, 33, 23] # P3/8 80*80 分辨率 特征图（小目标） - [30, 61, 62, 45, 59, 119] # P4/16 40*40 分辨率 特征图中目标 - [116, 90, 156, 198, 373, 326] # P5/32 20*20 分辨率 特征图大目标# YOLOv5 v6.0 backbonebackbone: # [from, number, module, args] [ [-1, 1, Conv, [64, 6, 2, 2]], # 0-P1/2 [-1, 1, Conv, [128, 3, 2]], # 1-P2/4 [-1, 3, C3, [128]], [-1, 1, Conv, [256, 3, 2]], # 3-P3/8 [-1, 6, C3, [256]], [-1, 1, Conv, [512, 3, 2]], # 5-P4/16 [-1, 9, C3, [512]], [-1, 1, Conv, [1024, 3, 2]], # 7-P5/32 [-1, 3, C3, [1024]], [-1, 1, SPPF, [1024, 5]], # 9 ]# YOLOv5 v6.0 headhead: [ [-1, 1, Conv, [512, 1, 1]], [-1, 1, nn.Upsample, [None, 2, &quot;nearest&quot;]], [[-1, 6], 1, Concat, [1]], # cat backbone P4 [-1, 3, C3, [512, False]], # 13 [-1, 1, Conv, [256, 1, 1]], [-1, 1, nn.Upsample, [None, 2, &quot;nearest&quot;]], [[-1, 4], 1, Concat, [1]], # cat backbone P3 [-1, 3, C3, [256, False]], # 17 (P3/8-small) [-1, 1, Conv, [256, 3, 2]], [[-1, 14], 1, Concat, [1]], # cat head P4 [-1, 3, C3, [512, False]], # 20 (P4/16-medium) [-1, 1, Conv, [512, 3, 2]], [[-1, 10], 1, Concat, [1]], # cat head P5 [-1, 3, C3, [1024, False]], # 23 (P5/32-large) [[17, 20, 23], 1, Detect, [nc, anchors]], # Detect(P3, P4, P5) ] 2.1.1 anchor结构anchor yolov5s 初始化9个 anchor，分别在三个特征图（feature.map）中使用每个特征图的每个grid cell 都有三个anchor进行预测，设置规则为： 尺度越大（80*80）的特征图（feature.map）越靠前，相对原始图像的下采样率越小，感受野越小，相对可以预测一些尺度较小的物体，分配到anchor越小，（分辨率高的P3特征图的每个grid cell 感受野小，只能看到局部细节，anchor小尺度[10,13]） 尺度越(20*20)小的特征图（feature.map）越靠后，相对原始图像的下采样率越大，感受野越大，相对可以预测尺度较大的物体，分配到的anchor越大 (分辨率低P5 的每个感受野大，覆盖区域大，anchor尺度大[372,326]) 在小特征图上检测大目标，中等大小的特征图上检测中等目标，在大特征图中检测小目标 补充 anchor 是通过k-mean聚类在COCO数据集上生成，固定为9个 （3个尺度且每个尺度对应3个anchor）；分辨率越高的特征图（如 P3=80×80大小，下采样率 8×），在输出层中越靠前，分配的 anchors 尺寸越小，用于检测小目标；分辨率越低的特征图（如 P5=20×20大小，下采样率 32×），在输出层中越靠后，分配的 anchors 尺寸越大，用于检测大目标。 yolov5 在训练中自动更新anchor（每1000次迭代）根据当前数据分布优化anchor（具体代码在utils/autoanchor.py） 每个特征图用的3个anchor是覆盖不同的宽高比（瘦高，扁宽，正方）例如 p5中 [116,90]-&gt;宽高比1.29 接近正方形[156,198]-&gt;宽高比0.79 （瘦高）[373,326]-&gt;宽高比1.14接近正方形，且3个平衡精度与计算量的最优解（2个anchor会降低小目标召回率） anchor尺寸=相对输入图像的绝对像素值（非归一化）,在P5的anchor中[116,90] 为width宽为116像素，height高为90像素。 2.1.2 anchor 匹配机制yolov5 在训练中动态匹配真实框到最优anchor 1234567891011121314（1）计算宽高比兼容性 对每个真实框（宽 w_gt, 高 h_gt）和每个anchor（宽w_a 高h_a）计算宽高比相似度 ratio=max（w_gt/w_a,w_a/w_gt,h_gt/h_a,h_a/h_gt）.默认anchor_t=4.0 当ratio&lt; anchor_t, 认为该anchor兼容此真实框。 （2）分配到最合适特征图兼容的anchor可能适用于多个特征图（P3(80*80),p4(40*40),P5(20*20)）。最终分配规则：选择该真实框最接近的特征图。真实框面积(S_gt)=w_gt*h_gt。且特征图有效检测范围由下采样决定P3（下采样8X）S_gt&lt;(8*4)^2=1024P4(下采样16X)1024&lt;S_gt&lt;(16*4)^2=4096P5(下采样32X)S_gt&gt;=4096(3)Grid cell 定位真实框中心点（x_c，y_c）落在那个grid cell，就由该grid cell 预测每个grid cell 仅使用1个anchor（即使有三个兼容anchor，只选IOU最大那个） anchor 在推理中作用预测偏移量，模型输出不是绝对坐标，而是相对anchor的偏移量：bx=f(tx)+cxby=f(ty)+cybw=Pwe^twbh=Pwe^thcx,cy为grid cell 左上角坐标Pw,Ph 为anchor宽高tx,ty,tw,th 模型输出的偏移量 自定义数据集时：运行python utils/autoanchor.py –data your_data.yaml 重新聚类 anchors。若小目标多，手动缩小 P3 的 anchors（如将 [10,13] 改为 [5,7]）。 anchor 分析工具：使用 utils/plot_labels.py 可视化 anchor 与真实框的匹配情况：python utils/plot_labels.py –batch 16 –data your_data.yaml 当模型检测效果差时：检查小目标召回率：若低 → 增大 P3 的 anchors 或增加输入分辨率（如 640→1280）。检查 大目标漏检：若多 → 增大 P5 的 anchors 或减小 anchor_t（如 4.0→2.0）。 总结 自定义数据集时务必重新聚类 anchors，并用 plot_labels.py 分析匹配质量。anchor 锚定多尺度检测的基石：Anchor 机制是 YOLOv5 高效检测的核心，理解其动态分配逻辑，比死记“9 个 anchors”更重要。实际应用中，根据数据分布调整 anchors 比盲目使用默认值提升效果更显著。 找个视频或文档逐行把代码看一下 目录结构和功能 绘制模型结构图 yolo v5 V8 v11 Unet系列 cycleGan 系列 找个深度学习是视频 通一遍基础 把简历有问题记录下 tensorrt","categories":[],"tags":[]},{"title":"日常工作","slug":"日常工作","date":"2025-05-21T03:01:12.000Z","updated":"2025-05-27T06:25:48.000Z","comments":true,"path":"2025/05/21/日常工作/","link":"","permalink":"http://example.com/2025/05/21/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"1 window 上 cuda和 版本 cuDNN12345678nvidia-smi查看当前显卡驱动最高支持的CUDA版本nvcc -V查看安装cuda版本 2 pytorch 下载whl 文件1234https://download.pytorch.org/whl/torch/ 3 用 venv 创建虚拟环境 1python -m venv myenv 4 在处理数据 把图像 统一保存为png 防止数据因为编解丢失 通过imagej 选择相同点位 来比较灰度值 5 使用 win+R 中 使用 mstsc 远程连接 12远程桌面 192.168.0.61lenovo/rt321 6 labelme 标注jSON 数据转MASK（掩膜）图像 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import jsonimport cv2import numpy as npimport osdef json_to_mask(json_path, output_mask_dir): &quot;&quot;&quot;将单个LabelMe JSON文件转换为掩膜图像&quot;&quot;&quot; with open(json_path, &#x27;r&#x27;) as f: data = json.load(f) # 从JSON中获取图像尺寸 height = data[&#x27;imageHeight&#x27;] width = data[&#x27;imageWidth&#x27;] image_shape = (height, width) # 创建全黑的背景掩膜 mask = np.zeros(image_shape, dtype=np.uint8) for shape in data[&#x27;shapes&#x27;]: if shape[&#x27;shape_type&#x27;] == &#x27;polygon&#x27;: points = np.array(shape[&#x27;points&#x27;], dtype=np.int32) cv2.fillPoly(mask, [points], color=255) elif shape[&#x27;shape_type&#x27;] == &#x27;rectangle&#x27;: x1 = int(round(shape[&#x27;points&#x27;][0][0])) y1 = int(round(shape[&#x27;points&#x27;][0][1])) x2 = int(round(shape[&#x27;points&#x27;][1][0])) y2 = int(round(shape[&#x27;points&#x27;][1][1])) cv2.rectangle(mask, (x1, y1), (x2, y2), 255, -1) elif shape[&#x27;shape_type&#x27;] == &#x27;circle&#x27;: # 计算圆心和半径 center = (int(round(shape[&#x27;points&#x27;][0][0])), int(round(shape[&#x27;points&#x27;][0][1]))) edge_point = (int(round(shape[&#x27;points&#x27;][1][0])), int(round(shape[&#x27;points&#x27;][1][1]))) radius = int(round(np.sqrt((edge_point[0]-center[0])**2 + (edge_point[1]-center[1])**2))) cv2.circle(mask, center, radius, 255, -1) elif shape[&#x27;shape_type&#x27;] == &#x27;line&#x27;: points = np.array(shape[&#x27;points&#x27;], dtype=np.int32) cv2.polylines(mask, [points], False, 255, thickness=2) # 生成输出路径 json_filename = os.path.basename(json_path) mask_filename = os.path.splitext(json_filename)[0] + &#x27;.png&#x27; output_path = os.path.join(output_mask_dir, mask_filename) # 确保输出目录存在 os.makedirs(output_mask_dir, exist_ok=True) # 保存掩膜图像 cv2.imwrite(output_path, mask) print(f&quot;生成掩膜：&#123;output_path&#125;&quot;)def batch_json_to_mask(input_dir, output_dir): &quot;&quot;&quot;批量处理目录中的所有JSON文件&quot;&quot;&quot; # 遍历输入目录 for filename in os.listdir(input_dir): if filename.lower().endswith(&#x27;.json&#x27;): json_path = os.path.join(input_dir, filename) json_to_mask(json_path, output_dir)if __name__ == &quot;__main__&quot;: # 使用示例 input_folder = &#x27;0527_Data/SegmentationClass_Origin&#x27; # 包含JSON和图片的文件夹 output_folder = &#x27;0527_Data/SegmentationClass&#x27; # 掩膜输出目录 # 执行批量转换 batch_json_to_mask(input_folder, output_folder) print(&quot;所有掩膜文件已生成完成！&quot;) 7 使用SAM2分割图像8 后续考虑用.bat exe来执行程序9 Scikit-learn 机器学习库","categories":[],"tags":[]},{"title":"hexo_博客_命令与配置","slug":"hexo-博客-命令与配置","date":"2025-01-23T06:19:04.000Z","updated":"2025-07-29T15:32:30.730Z","comments":true,"path":"2025/01/23/hexo-博客-命令与配置/","link":"","permalink":"http://example.com/2025/01/23/hexo-%E5%8D%9A%E5%AE%A2-%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"hexo 博客常用命令本地启动 1hexo s 本地文件生成 1hexo g 创建一篇新博客 1hexo new &quot;博客名称&quot; 上传到github 1hexo deploy 在一篇博客中插入一张图像 vm中设置-图像标题名6-4.jpg-生成md文件时，对应生成文件夹中存入图像","categories":[],"tags":[]},{"title":"红外图像处理算法总结","slug":"红外图像处理算法总结","date":"2025-01-23T06:17:36.000Z","updated":"2025-01-25T05:20:17.490Z","comments":true,"path":"2025/01/23/红外图像处理算法总结/","link":"","permalink":"http://example.com/2025/01/23/%E7%BA%A2%E5%A4%96%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.基于k-mean聚类红外图像压缩，拟合，重建算法算法步骤： 1.读取红外图像序列2.选取平稳降温阶段差异较大区域作为新的序列3，使用k-mean进行聚类，得到k个类别，对每个类别序列计算平均序列，用平均序列代替各个序列4 使用TSR（热波信号重建技术）拟合图像序列得出多项式拟合参数，保留序列类别，位置信息，多项式拟合参数作为压缩参数5 使用压缩参数重建热波温度衰减曲线，将每个像素点温度变化还原位置，重建热波图像序列2 CycleGAN 循环一致对抗神经网络123CycleGan由两个生成器G和F 两个判别器Dx和Dy 生成器G 将X域反光图像转为Y域的清晰图像 生成器F 将Y域清晰图像转为X域的反光图像 CycleGan 的生成器为双分支网络，一分支网络为小波变换网络，通过提取图像高低频域信息，另一个分支网络为知识蒸馏网络，提取图像中光圈和光晕 3 基于遗传算法的图像融合算法123456789图像融合效果取决于最佳分层阈值和融合权重系数； 步骤： 1.选择两幅温度差异大图像，计算得出差值图像2.初始化遗传算法参数3.构建适应度函数4.选择，变异，交叉操作5，评估适度度，输出最优个体6，判断是否迭代到最大次数，是为输出最佳分层阈值和融合权重 否 继续遗传算法操作 4 基于双指数模型12345 5 yolov812345yolov8 有三个部分组成","categories":[],"tags":[]},{"title":"c++多元线性回归","slug":"c-多元线性回归","date":"2024-01-10T06:48:53.000Z","updated":"2024-01-10T06:51:37.080Z","comments":true,"path":"2024/01/10/c-多元线性回归/","link":"","permalink":"http://example.com/2024/01/10/c-%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","excerpt":"","text":"求解多元线性回归方程及参数 上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define v_v_d vector&lt;vector&lt;double&gt;&gt;#define v_d vector&lt;double&gt;// 解线性方程。data[count*(count+1)]矩阵数组；count：方程元数；// Answer[count]：求解数组 。返回：0求解成功，-1无解或者无穷解//重载的辅助函数void j_memcpy(v_d::iterator dat, v_d d, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; dat[i] = d[i]; &#125;&#125;void j_memcpy(v_d &amp;dat, v_d d, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; dat[i] = d[i]; &#125;&#125;void j_memcpy(v_d &amp; dat, v_d::iterator d, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; dat[i] = d[i]; &#125;&#125;void j_memcpy(v_d::iterator dat, v_d::iterator d, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; dat[i] = d[i]; &#125;&#125;void itSum(v_d::iterator &amp; it, int n, v_d &amp; data)&#123; int t = 0; while (it != data.end() &amp;&amp; t++ &lt; n) it++;&#125;//迭代器版本int LinearEquationsCjj(vector&lt;double&gt; &amp;data, int count, double *Answer)&#123; int j, m, n; vector&lt;double&gt; ::iterator d = data.begin(); //double *d = data; double tmp; //double *d = data; vector&lt;vector&lt;double&gt;&gt; dat; dat = vector&lt;vector&lt;double&gt;&gt;(count); //dat = (double**)malloc(count * sizeof(double*)); for (m = 0; m &lt; count; m++, itSum(d, count + 1, data)) &#123; dat[m] = vector&lt;double&gt;(count + 1); //dat[m] = (double*)malloc((count + 1) * sizeof(double)); j_memcpy(dat[m], d, count + 1); //memcpy(dat[m], d, (count + 1) * sizeof(double)); &#125; vector&lt;double&gt; jj = v_d(count + 1); d = jj.begin(); //d = (double*)malloc((count + 1) * sizeof(double)); for (m = 0; m &lt; count - 1; m++) &#123; // 如果主对角线元素为0，行交换 for (n = m + 1; n &lt; count &amp;&amp; dat[m][m] == 0.0; n++) &#123; if (dat[n][m] != 0.0) &#123; j_memcpy(d, dat[m], (count + 1)); j_memcpy(dat[m], dat[n], (count + 1)); j_memcpy(dat[n], d, (count + 1)); //memcpy(d, dat[m], (count + 1) * sizeof(double)); //memcpy(dat[m], dat[n], (count + 1) * sizeof(double)); //memcpy(dat[n], d, (count + 1) * sizeof(double)); &#125; &#125; // 行交换后，主对角线元素仍然为0，无解，返回-1 if (dat[m][m] == 0.0) &#123; //FreeData(dat, d, count); return -1; &#125; // 消元 for (n = m + 1; n &lt; count; n++) &#123; tmp = dat[n][m] / dat[m][m]; for (j = m; j &lt;= count; j++) dat[n][j] -= tmp * dat[m][j]; &#125; &#125; for (j = 0; j &lt; count; j++) d[j] = 0.0; // 求得count - 1的元 Answer[count - 1] = dat[count - 1][count] / dat[count - 1][count - 1]; // 逐行代入求各元 for (m = count - 2; m &gt;= 0; m--) &#123; for (j = count - 1; j &gt; m; j--) d[m] += Answer[j] * dat[m][j]; Answer[m] = (dat[m][count] - d[m]) / dat[m][m]; &#125; //FreeData(dat, d, count); return 0;&#125;// 求多元回归方程：Y = B0 + B1X1 + B2X2 + ...BnXn// data[rows*cols]二维数组；X1i,X2i,...Xni,Yi (i=0 to rows-1)// rows：数据行数；cols数据列数；Answer[cols]：返回回归系数数组(B0,B1...Bn)// 返回值：0求解成功，-1错误//迭代器版本int MultipleRegressionCjj(vector&lt;double&gt; &amp;data, int rows, int cols, double *Answer)&#123; int m, n, i, count = cols - 1; double a, b; vector&lt;double&gt; ::iterator p; vector&lt;double&gt;dat; if (data.size() == 0 || Answer == 0 || rows &lt; 2 || cols &lt; 2) return -1; dat = vector&lt;double&gt;(cols * (cols + 1)); dat[0] = (double)rows; for (n = 0; n &lt; count; n++) // n = 0 to cols - 2 &#123; if (n == 1) &#123; int jhasd = 1; &#125; a = b = 0.0; for (p = data.begin() + n, m = 0; m &lt; rows; m++, itSum(p, cols, data)) &#123; int my = *p; a += *p; b += (*p * *p); &#125; dat[n + 1] = a; // dat[0, n+1] = Sum(Xn) dat[(n + 1) * (cols + 1)] = a; // dat[n+1, 0] = Sum(Xn) dat[(n + 1) * (cols + 1) + n + 1] = b; // dat[n+1,n+1] = Sum(Xn * Xn) for (i = n + 1; i &lt; count; i++) // i = n+1 to cols - 2 &#123; for (a = 0.0, p = data.begin(), m = 0; m &lt; rows; m++, itSum(p, cols, data)) a += (p[n] * p[i]); dat[(n + 1) * (cols + 1) + i + 1] = a; // dat[n+1, i+1] = Sum(Xn * Xi) dat[(i + 1) * (cols + 1) + n + 1] = a; // dat[i+1, n+1] = Sum(Xn * Xi) &#125; &#125; for (b = 0.0, m = 0, p = data.begin() + n; m &lt; rows; m++, itSum(p, cols, data)) b += *p; dat[cols] = b; // dat[0, cols] = Sum(Y) for (n = 0; n &lt; count; n++) &#123; for (a = 0.0, p = data.begin(), m = 0; m &lt; rows; m++, itSum(p, cols, data)) a += (p[n] * p[count]); dat[(n + 1) * (cols + 1) + cols] = a; // dat[n+1, cols] = Sum(Xn * Y) &#125; n = LinearEquationsCjj(dat, cols, Answer); // 计算方程式 return n;&#125;void Display(double *dat, double *Answer, double *SquarePoor, int rows, int cols)&#123; double v, *p; int i, j; printf(&quot;回归方程式: Y = %.5lf&quot;, Answer[0]); for (i = 1; i &lt; cols; i++) printf(&quot; + %.5lf*X%d&quot;, Answer[i], i); system(&quot;pause&quot;);&#125;double _data[15][5] = &#123; // X1 X2 X3 X4 Y &#123; 316, 1536, 874, 981, 3894 &#125;, &#123; 385, 1771, 777, 1386, 4628 &#125;, &#123; 299, 1565, 678, 1672, 4569 &#125;, &#123; 326, 1970, 785, 1864, 5340 &#125;, &#123; 441, 1890, 785, 2143, 5449 &#125;, &#123; 460, 2050, 709, 2176, 5599 &#125;, &#123; 470, 1873, 673, 1769, 5010 &#125;, &#123; 504, 1955, 793, 2207, 5694 &#125;, &#123; 348, 2016, 968, 2251, 5792 &#125;, &#123; 400, 2199, 944, 2390, 6126 &#125;, &#123; 496, 1328, 749, 2287, 5025 &#125;, &#123; 497, 1920, 952, 2388, 5924 &#125;, &#123; 533, 1400, 1452, 2093, 5657 &#125;, &#123; 506, 1612, 1587, 2083, 6019 &#125;, &#123; 458, 1613, 1485, 2390, 6141 &#125;,&#125;;int main002()&#123; //根据输入的数据矩阵，和给定的回归元数，训练给出回归方程式 double Answer[5], SquarePoor[4]; int rows = 15, cols = 5;//表示有15组数据，共4元线性回归，计算给出回归方程式 v_d j_data;//data可变数组 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; j_data.push_back(_data[i][j]); &#125; &#125; if (MultipleRegressionCjj(j_data, rows, cols, Answer) == 0) Display((double*)_data, Answer, SquarePoor, rows, cols); return 0;&#125;","categories":[],"tags":[]},{"title":"c++读取txt","slug":"c-读取txt","date":"2024-01-10T02:43:46.000Z","updated":"2024-01-10T06:42:52.913Z","comments":true,"path":"2024/01/10/c-读取txt/","link":"","permalink":"http://example.com/2024/01/10/c-%E8%AF%BB%E5%8F%96txt/","excerpt":"","text":"直接读取参数的txt文件 上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include&lt;sstream&gt;int main()&#123; std::ifstream file; float parameter[8]; //ifstream file; file.open(&quot;parameter/参数文件.txt&quot;);//指定文件路径 if(!file) &#123; printf(&quot;参数文件为空 \\n&quot;); //pause(system); &#125; printf(&quot;参数文件已经读取 \\n&quot;); //std::vector&lt;float&gt; target_1, target_2; //用于存放目标数据 std::vector&lt;std::string&gt; item; //用于存放文件中的一行数据 std::string temp; while (getline(file, temp)) //利用getline（）读取每一行，并放入到 item 中 &#123; item.push_back(temp); &#125; for (auto it= item.begin();it!=item.end();it++) &#123; //printf(&quot;%s \\n&quot;,item[i]); //item[i]; std::istringstream istr(*it); std::string str; istr &gt;&gt; str; std::vector&lt;std::string&gt; res; if(str == &quot;&quot;) &#123; printf(&quot;error&quot;); &#125; std::string str_s=&quot;=&quot;; size_t pos = str.find(str_s); std::string str_1=str.substr(pos+1); float r=atof(str_1.c_str()); printf(&quot;%.1f \\n&quot;, r); &#125; file.close(); return 0;&#125;","categories":[],"tags":[]},{"title":"cycleGan环境配置","slug":"cycleGan环境配置","date":"2024-01-04T02:03:58.000Z","updated":"2024-01-04T09:54:41.327Z","comments":true,"path":"2024/01/04/cycleGan环境配置/","link":"","permalink":"http://example.com/2024/01/04/cycleGan%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"查看nvidia显存 和cuda版本12345678910111213141516查看显存nvidia-smi查看cuda 版本nvcc -V安装pytorch 后，查看cuda是否正常开启import torchtorch.cuda.is_available()当返回True 为开启 安装pytorch 需要注意的地方123456在2024.1.4是pytorch 2.1.2 只支持python3.11及以下版本，3.12不支持且cuda版本是向下兼容（cuda电脑版本可高于pytorch所需版本）在wheel包，cp38-cp39 是指对应python3.8和python3.9 配置python 虚拟环境 venv创建虚拟环境(python3自带) 12345678910111213第一步，创建项目目录mkdir python_venv_demo第二步，进入改文件目录cd python_venv_demo第三步，创建虚拟环境python -m venv venv_demo # venv_demo 就是虚拟环境的名字注意：python3 内置了venv，所以不用再pip安装virtualenv了。第四步，激活虚拟环境（只有激活之后才能进入虚拟环境）cd venv_demo/Scriptsactivate.bat激活成功后，终端提示符会显示虚拟环境的名称。退出虚拟环境deactivate.bat virtualenvwrapper创建虚拟环境 1234567891011121314151617181920212223242526272829303132鉴于virtualenv不便于对虚拟环境集中管理，所以推荐直接使用virtualenvwrapper，virtualenvwrapper便于操作，使工作便利。安装virtualenvwrapperpip install virtualenvwrapper-win创建虚拟环境mkvirtualenv venv_demo # venv_demo 就是虚拟环境的名字 创建指定python版本的虚拟环境mkvirtualenv venv_demo -p python路径 # venv_demo 就是虚拟环境的名字 创建 的虚拟环境默认放在C:\\Users\\Administrator\\Envs目录中修改默认存放路径添加一个环境变量，系统设置中添加WORKON_HOME D:\\Evns查看有哪些虚拟环境workon进入虚拟环境workon 虚拟环境名称退出虚拟环境deactivate删除虚拟环境rmvirtualenv 虚拟环境名称 pip 升级(针对升级pip报错)1234567891011先升级setuptoolspip install --upgrade setuptools可以查看升级后版本是否更高了python -m pip show setuptools再升级pippython -m pip install --upgrade pip查看当前的pip版本pip --version python 换国内源1234指令：pip config set global.index-url 国内源地址换的是清华的源pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/ cyclegan 一些调试参数12345678910111213141516171819202122232425262728293031323334输出结果（输出图像代表含义）real_A:表示输入的真实的A图片real_B:表示输入的真实的B图片fake_B:表示真实图片A生成的假冒B风格图片fake_A:表示真实图片B生成的假冒A风格图片rec_A：表示fake_B再生成回A风格图片rec_B：表示fake_A再生成回B风格图片idt_B：表示真实图片A生成的A风格图片idt_A：表示真实图片B生成的B风格图片改变输出图片分辨率在base_option.py中修改eg： parser.add_argument(&#x27;--load_size&#x27;, type=int, default=1024, help=&#x27;scale images to this size&#x27;) parser.add_argument(&#x27;--crop_size&#x27;, type=int, default=1024, help=&#x27;then crop to this size&#x27;)即可得到1024 * 1024的输出结果。//测试一下好像改不了训练轮次指定 parser.add_argument(&#x27;--n_epochs&#x27;, type=int, default=100, help=&#x27;number of epochs with the initial learning rate&#x27;) parser.add_argument(&#x27;--n_epochs_decay&#x27;, type=int, default=100, help=&#x27;number of epochs to linearly decay learning rate to zero&#x27;)解释见help，总共n_epochs + n_epochs_dacay轮每隔多少轮保存一次权重 parser.add_argument(&#x27;--save_epoch_freq&#x27;, type=int, default=5, help=&#x27;frequency of saving checkpoints at the end of epochs&#x27;)","categories":[],"tags":[]},{"title":"GAN学习笔记1","slug":"GAN学习笔记1","date":"2023-12-30T02:14:51.000Z","updated":"2023-12-30T02:18:27.792Z","comments":true,"path":"2023/12/30/GAN学习笔记1/","link":"","permalink":"http://example.com/2023/12/30/GAN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"GAN（生成对抗网络）是一类用于生成模型的神经网络模型，它由生成器和判别器两个部分组成。下面是一些常见的GAN网络模型： 原始的GAN（GAN, Generative Adversarial Network）：由Ian Goodfellow等人于2014年提出的最早的GAN模型。 DCGAN（Deep Convolutional GAN）：在原始GAN的基础上，引入了卷积神经网络结构，适用于图像生成任务。 CGAN（Conditional GAN）：在GAN中加入条件信息，使得生成器能够根据给定条件生成符合要求的样本。 WGAN（Wasserstein GAN）：采用Wasserstein距离作为损失函数，解决了GAN训练过程中的模式崩溃和不稳定性问题。 CycleGAN：用于图像转换任务，可以实现不同领域之间的图像转换，如马到斑马、苹果到橙子等。 Pix2Pix：用于图像翻译任务，将输入图像转换为输出图像，如黑白照片到彩色照片、草图到真实图像等。 StyleGAN（Style-Generative Adversarial Network）：通过学习图像的风格和内容分离的方式，实现高分辨率图像的生成。 这些仅是GAN模型中的一部分，随着研究的深入和发展，还有许多其他的GAN变体和改进模型。 123456789101112131415有几种常见的基于GAN的图像修复模型，可以用于图像修复任务。以下是其中一些常见的GAN模型：Context Encoders（Inpainting GAN）：这是最早的图像修复GAN模型之一，由Pathak等人在2016年提出。该模型通过学习将缺失部分的图像恢复为完整的图像。PatchGAN：这是一种常用于图像修复的判别器架构。它不仅评估整个图像的真实性，还评估图像中每个局部区域（patch）的真实性，从而使生成器能够更好地还原缺失区域。SRGAN（Super-Resolution GAN）：这是用于图像超分辨率（图像放大）任务的GAN模型。它可以将低分辨率图像转换为高分辨率图像，以实现图像的清晰度提升。DeepFillv1/v2/v3：这是一种基于GAN的图像修复模型，由NVIDIA提出。它通过学习图像的上下文信息，自动填充缺失的部分。EdgeConnect：这是一种专门用于图像修复的GAN模型，它可以根据图像的边界信息进行修复，使得修复结果更加准确和自然。这些模型基于GAN的框架，通过学习大量的图像数据进行训练，以生成具有高质量修复效果的图像。当然，还有其他一些模型和技术可用于图像修复任务，这里只是列举了一些常见的GAN模型。 12345678910在图像处理中，去除遮挡也是一个重要的任务。下面是一些常见的基于GAN的去除遮挡模型：GLEAN（Generative Latent Embedded Appearance Model）：这是一种用于去除人脸遮挡的GAN模型。它通过学习将遮挡部分的人脸图像恢复为完整的人脸图像。FaceInpainting：这是一种用于去除人脸遮挡的GAN模型。它可以通过学习将遮挡部分的人脸图像恢复为完整的人脸图像，同时保持人脸的真实性和连续性。Deocclusion GAN：这是一种用于去除遮挡的通用GAN模型，它可以去除任何类型的遮挡，包括物体、人、背景等。这些基于GAN的去除遮挡模型，可以通过学习大量的图像数据进行训练，以生成具有高质量去除遮挡效果的图像。当然，还有其他一些模型和技术可用于去除遮挡任务，这里只是列举了一些常见的GAN模型。 CycleGAN 是一种基于生成对抗网络（GAN）的图像转换模型。它的主要目标是实现两个不同领域之间的图像转换，而无需成对的训练数据。 CycleGAN 的用途非常广泛，以下是一些常见的应用场景： 风格迁移：CycleGAN 可以将一种风格的图像转换为另一种风格，例如将油画风格的图像转换为真实照片风格，或者将夏季风格的图像转换为冬季风格的图像。 图像翻译：CycleGAN 可以在不同语义领域之间进行图像转换，例如将马的图像转换为斑马的图像，将苹果的图像转换为橘子的图像等。 动漫风格转换：CycleGAN 可以将真实照片转换为动漫风格的图像，或者将动漫风格的图像转换为真实照片风格，实现动漫化效果。 图像增强和修复：CycleGAN 可以将低质量图像转换为高质量图像，或者将有缺陷的图像修复为完整的图像。 跨摄影设备转换：CycleGAN 可以将一种摄影设备拍摄的图像转换为另一种摄影设备的图像，例如将手机拍摄的图像转换为单反相机拍摄的图像。 需要注意的是，CycleGAN 模型的训练过程可能需要大量的数据和计算资源。此外，模型的性能也受到训练数据的质量和多样性的影响。因此，在实际使用中，需要根据具体任务和数据情况进行适当的调整和优化。 12345","categories":[],"tags":[]},{"title":"raw文件的保存和读取处理","slug":"raw文件的保存和读取处理","date":"2023-12-21T07:54:39.000Z","updated":"2023-12-21T07:54:39.118Z","comments":true,"path":"2023/12/21/raw文件的保存和读取处理/","link":"","permalink":"http://example.com/2023/12/21/raw%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96%E5%A4%84%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"提示和总结","slug":"提示和总结","date":"2023-12-21T02:23:00.000Z","updated":"2023-12-21T02:28:19.468Z","comments":true,"path":"2023/12/21/提示和总结/","link":"","permalink":"http://example.com/2023/12/21/%E6%8F%90%E7%A4%BA%E5%92%8C%E6%80%BB%E7%BB%93/","excerpt":"","text":"重搞一下热像仪数据采集的工具，不能用8位的编解码的数据用16位数据来处理的，8位效果实在太差的，后续需要从图像重建的方式上来提升图像，强反光需要拉低阈值来处理的 抽时间把年终总结写一下的和对明年规划","categories":[],"tags":[]},{"title":"c++继承","slug":"c-继承","date":"2023-11-20T01:44:40.000Z","updated":"2023-11-20T03:28:56.392Z","comments":true,"path":"2023/11/20/c-继承/","link":"","permalink":"http://example.com/2023/11/20/c-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"c++ 继承在C++中，继承是一种面向对象编程的重要概念，它允许一个类（称为派生类）从另一个类（称为基类）那里继承属性（数据）和行为（方法）。这使得代码重用变得更加容易，并且有助于建立层次化的类关系。 1234567891011121314151617181920212223242526272829303132333435363738// 基类class Shape &#123;public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125;protected: int width; int height;&#125;;// 派生类class Rectangle : public Shape &#123;public: int getArea() &#123; return (width * height); &#125;&#125;;int main() &#123; Rectangle rect; rect.setWidth(5); rect.setHeight(7); // 使用从基类继承的函数 int area = rect.getArea(); cout &lt;&lt; &quot;Area of the rectangle: &quot; &lt;&lt; area &lt;&lt; endl; return 0;&#125; 上述代码中Rectangle 类通过 public 关键字继承了 Shape 类。这意味着 Rectangle 类可以访问 Shape 类中的 setWidth 和 setHeight 方法，可以通过继承的数据成员 width 和 height 计算矩形的面积。 继承还可以分为不同的类型，比如公有继承、私有继承和保护继承，它们决定了派生类对基类成员的访问权限。此外，C++ 还提供了虚继承和多重继承等高级特性，以满足更复杂的类关系需求。 多重继承多重继承指的是一个派生类同时继承自多个基类。这种特性使得派生类可以获得多个基类的属性和行为，从而支持更加丰富的类关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 基类 Shapeclass Shape &#123;public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125;protected: int width; int height;&#125;;// 基类 Colorclass Color &#123;public: void setColor(string c) &#123; color = c; &#125;protected: string color;&#125;;// 派生类 Rectangle，同时继承自 Shape 和 Colorclass Rectangle : public Shape, public Color &#123;public: int getArea() &#123; return (width * height); &#125;&#125;;int main() &#123; Rectangle rect; rect.setWidth(5); rect.setHeight(7); rect.setColor(&quot;Red&quot;); cout &lt;&lt; &quot;Area of the rectangle: &quot; &lt;&lt; rect.getArea() &lt;&lt; endl; cout &lt;&lt; &quot;Color of the rectangle: &quot; &lt;&lt; rect.color &lt;&lt; endl; return 0;&#125; 上述代码中Rectangle 类同时继承自 Shape 和 Color 两个基类，因此Rectangle可以使用这两个基类中定义的方法和数据成员。 虚继承虚继承用于解决多重继承可能引发的菱形继承问题（Diamond Inheritance Problem）。通过虚继承，可以确保在多重继承中共享的基类子对象只有一个实例。以下是一个简单的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041// 基类 Animalclass Animal &#123;public: void eat() &#123; cout &lt;&lt; &quot;Animal eats&quot; &lt;&lt; endl; &#125;&#125;;// 虚继承的基类class Mammal : public virtual Animal &#123;public: void run() &#123; cout &lt;&lt; &quot;Mammal runs&quot; &lt;&lt; endl; &#125;&#125;;// 虚继承的基类class Bird : public virtual Animal &#123;public: void fly() &#123; cout &lt;&lt; &quot;Bird flies&quot; &lt;&lt; endl; &#125;&#125;;// 派生类 Bat，同时继承自 Mammal 和 Birdclass Bat : public Mammal, public Bird &#123;&#125;;int main() &#123; Bat bat; bat.eat(); // 可以调用从 Animal 继承的方法 bat.run(); // 调用从 Mammal 继承的方法 bat.fly(); // 调用从 Bird 继承的方法 return 0;&#125; 在这个示例中，Bat 类同时继承自 Mammal 和 Bird 两个基类，而这两个基类都虚继承自 Animal。这样就避免了由于多重继承而导致的 Animal 类对象在 Bat 对象中出现多份的问题。","categories":[],"tags":[]},{"title":"QT_信号和槽","slug":"QT-信号和槽","date":"2023-11-17T09:26:45.000Z","updated":"2023-11-17T09:34:06.396Z","comments":true,"path":"2023/11/17/QT-信号和槽/","link":"","permalink":"http://example.com/2023/11/17/QT-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/","excerpt":"","text":"信号和槽信号槽是 Qt 框架引以为豪的机制之一。实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，用自己的一个函数（成为槽（slot））来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。） 1观察者模式是一种行为设计模式，它定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会得到通知并自动更新。以下是根据Gang of Four（GoF）经典的观察者模式实现的方式： Subject（目标）：目标维护一组观察者，并提供方法来增加、删除和通知观察者。 1234567891011121314151617181920212223242526class Subject &#123;public: virtual void attach(Observer* observer) = 0; virtual void detach(Observer* observer) = 0; virtual void notify() = 0;&#125;;//////代码是C++中的抽象类 Subject 的定义，它定义了观察者模式中目标（Subject）的接口:virtual void attach(Observer* observer) = 0;：这是一个纯虚函数（pure virtual function），通过在函数声明的末尾加上= 0来声明。这意味着任何继承自 Subject 的类都必须实现这个函数，否则它们也会成为抽象类。virtual void detach(Observer* observer) = 0;：同样是一个纯虚函数，用于从主题中移除观察者。virtual void notify() = 0;：这也是一个纯虚函数，用于通知所有的观察者，当具体主题状态发生改变时调用这个方法来通知观察者。通过将这些方法声明为纯虚函数，类 Subject 成为了一个抽象类，不能被实例化。任何想要使用观察者模式的具体主题类都必须继承自 Subject，并且实现这些纯虚函数，以便为具体的观察者模式提供特定的功能。这种设计使得观察者模式中的目标类成为一个通用的抽象接口，具体的业务逻辑可以在其子类中实现，同时保持了对观察者的松耦合，符合面向对象设计中的开闭原则。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061ConcreteSubject（具体目标）：具体目标是目标类的子类，它负责维护目标的状态，并在状态发生变化时通知所有注册的观察者。cppclass ConcreteSubject : public Subject &#123;private: vector&lt;Observer*&gt; observers; int state;public: void attach(Observer* observer) override &#123; observers.push_back(observer); &#125; void detach(Observer* observer) override &#123; // Remove the observer from the list &#125; void notify() override &#123; for (Observer* observer : observers) &#123; observer-&gt;update(); &#125; &#125; int getState() &#123; return state; &#125; void setState(int state) &#123; this-&gt;state = state; notify(); &#125;&#125;;Observer（观察者）：观察者定义一个更新接口，以便在目标状态发生变化时得到通知。cppclass Observer &#123;public: virtual void update() = 0;&#125;;ConcreteObserver（具体观察者）：具体观察者是观察者类的子类，它实现了更新接口，并且在接收到通知时可以访问目标的状态。cppclass ConcreteObserver : public Observer &#123;private: ConcreteSubject* subject; int observerState;public: ConcreteObserver(ConcreteSubject* subject) &#123; this-&gt;subject = subject; subject-&gt;attach(this); &#125; void update() override &#123; observerState = subject-&gt;getState(); // Perform necessary actions based on the updated state &#125;&#125;;通过上述实现，当具体目标的状态发生变化时，它会调用notify方法通知所有观察者，而具体观察者会在update方法中接收通知并作出相应的处理。这种实现方式使得目标与观察者之间呈现松耦合的关系，同时允许动态地添加或删除观察者，以实现灵活的消息通知机制。","categories":[],"tags":[]},{"title":"“总结（2023/11/17）”","slug":"“总结（2023-11-17）”","date":"2023-11-17T07:07:20.000Z","updated":"2023-11-17T09:10:58.671Z","comments":true,"path":"2023/11/17/“总结（2023-11-17）”/","link":"","permalink":"http://example.com/2023/11/17/%E2%80%9C%E6%80%BB%E7%BB%93%EF%BC%882023-11-17%EF%BC%89%E2%80%9D/","excerpt":"","text":"工作总结熟悉华景康SDK调用的。 QLable 显示图像 和绘制ROI 大体代码完成，后续还需要修改， 温度的提取和显示也完成 温度数据（点，线 ，圆，矩形）保存csv文件 下周计划完成csv温度数据显示和处理界面（包括原始数据界面显示，降温变化率曲线和拟合曲线，能量）看有时间把QT学一下的（MFC）和（C#）也估计得了解一下","categories":[],"tags":[]},{"title":"‘图像算法一些思路’","slug":"‘图像算法一些思路’","date":"2023-11-08T06:22:25.000Z","updated":"2023-11-10T03:07:46.718Z","comments":true,"path":"2023/11/08/‘图像算法一些思路’/","link":"","permalink":"http://example.com/2023/11/08/%E2%80%98%E5%9B%BE%E5%83%8F%E7%AE%97%E6%B3%95%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF%E2%80%99/","excerpt":"","text":"去除图像中光斑得一些思路12345678910111.通过opencv找到图像中光斑区域，对确定得光斑区域做高斯模糊处理2.使用填充方式抑制光斑区域对图像的影响；一些思路后续补充 123456789101112先把图像放大功能做出来gcv格式数据保存下来在gcv格式文件下 处理出csv格式的文件，并通过QT读取csv文件完成处理QGraphicsView（不用Qlabel）在回调函数线程中 不要做显示和处理 程序容易崩，把回调函数以emit方式发送出来，再做显示和控制","categories":[],"tags":[]},{"title":"test-m","slug":"test-m","date":"2023-11-08T06:12:02.000Z","updated":"2023-11-08T06:19:54.205Z","comments":true,"path":"2023/11/08/test-m/","link":"","permalink":"http://example.com/2023/11/08/test-m/","excerpt":"","text":"用来测试hexo blog 日志的123456789101112131415后续得有些计划和安排 ，技术需要时不时写一些总结性安排得东西，不能只是干完了，就算了hexo n &#x27;名称&#x27;后续有时间更新到githuib上包括matlab 和python写得一些脚本","categories":[],"tags":[]},{"title":"多线程","slug":"多线程","date":"2023-06-30T02:58:53.000Z","updated":"2023-06-30T06:51:18.978Z","comments":true,"path":"2023/06/30/多线程/","link":"","permalink":"http://example.com/2023/06/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"面临的业务（多线程处理相机的发送图像）1234567891011121314151617首先得创建一个单独线程进行图像数据使用同步机制方式来保护共享数据的访问 ，确保在读取或修改数据时，只有一个线程能够进行操作（同步机制）1 互斥锁（Mutex）互斥锁用于保护共享资源，一次只允许一个线程访问共享资源。当一个线程获得了互斥锁后，其他线程需要等待该线程释放锁才能访问共享资源。2 条件变量 （Condition Variable）：条件变量用于实现线程间的等待和通知机制。一个线程可以在条件变量上等待某个条件满足，而另一个线程可以通过发送信号或通知来唤醒等待的线程。 （类似 if else）3. 信号量 （Semaphore）：信号量是一个计数器，用于控制同时访问共享资源的线程数量。当信号量计数器大于0时，线程可以继续执行；当计数器为0时，线程需要等待其他线程释放信号量。4. 屏障（Barrier）：屏障用于确保多个线程在某个点上同步执行。当所有线程都到达屏障点时，它们才会继续执行下一步操作。5. 原子操作（Atomic Operation）：原子操作是不可被中断的操作，可以确保在多线程环境下对共享变量的读写是安全的。原子操作通常通过硬件机制来保证操作的原子性。在使用同步机制时，要避免死锁（Deadlock）和竞态条件（Race Condition）等问题。合理设计线程的执行顺序和资源的访问方式可以帮助避免这些问题的发生。 互斥锁123456std::lock_guard&lt;std::mutex&gt; lock(mtx);","categories":[],"tags":[]},{"title":"QT初学-1","slug":"QT初学-1","date":"2023-05-11T01:45:10.000Z","updated":"2023-06-30T01:22:29.934Z","comments":true,"path":"2023/05/11/QT初学-1/","link":"","permalink":"http://example.com/2023/05/11/QT%E5%88%9D%E5%AD%A6-1/","excerpt":"","text":"QT常用的API123456move 移动窗口到父窗口某个坐标resize 重新设置窗口的大小setFixedSize 设置窗口的固定大小setWindowTitle 设置窗口标题setGeometry 同时设置窗口位置和大小，相当于move和resize的结合体 提高的按钮的生命周期1231.static2.类成员变量3 new 一个，动态内存分配 信号和槽12345678910111213141516QPushButton * quitBtn = new QPushButton(&quot;关闭窗口&quot;,this);connect(quitBtn,&amp;QPushButton::clicked,this,&amp;MyWidget::close);第二行就是核心了，也就是信号槽的使用方式connect函数是建立信号发送者、信号、信号接收者、槽四者关系的函数：connect(sender, signal, receiver, slot);参数解释：sender：信号发送者signal：信号receiver：信号接收者slot：接收对象在接收到信号之后所需要调用的函数（槽函数）这里要注意的是connect的四个参数都是指针，信号和槽是函数指针，使用connect的时候保留&amp;符号。","categories":[],"tags":[]},{"title":"分水岭算法","slug":"分水岭算法","date":"2023-05-04T07:19:46.000Z","updated":"2023-05-04T07:19:46.657Z","comments":true,"path":"2023/05/04/分水岭算法/","link":"","permalink":"http://example.com/2023/05/04/%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"激光束基本概念","slug":"激光束基本概念","date":"2023-04-04T08:46:04.000Z","updated":"2023-04-04T09:48:14.545Z","comments":true,"path":"2023/04/04/激光束基本概念/","link":"","permalink":"http://example.com/2023/04/04/%E6%BF%80%E5%85%89%E6%9D%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"1激光发散角是指激光束从激光器中发出后，扩散的角度。一般来说，激光束在传输过程中会由于大气折射、光学元件不完美等因素而扩散。激光发散角越小，表示激光束的能量越集中，适用于需要精细加工或远距离通信等场合；相反，激光发散角越大，表示激光束的能量分布越广泛，适用于需要覆盖面积较大的照明或投影等场合 2激光脉冲宽度是指激光器输出的脉冲持续时间。通常情况下，激光的脉冲宽度非常短，一般在纳秒（ns）或皮秒（ps）级别。激光脉冲宽度的长短对于激光在各种应用领域中的行为和性能具有至关重要的影响。例如，在激光打印机中，短脉冲宽度可使打印速度更快且印刷质量更高；在激光医疗设备中，短脉冲宽度可以精确控制激光能量的输送，从而避免对周围组织的损伤。需要注意的是，不同应用领域对激光脉冲宽度的要求也会有所差异。 3激光束波长是指激光器发出的激光波长。激光的波长通常在可见光、红外线或紫外线范围内，并且不同类型的激光器具有不同的波长范围。例如，二氧化碳激光器的波长为10.6微米，用于切割和焊接材料；Nd:YAG激光器的波长为1.064微米，用于医疗、通信和制造等领域；半导体激光器的波长范围从近红外到蓝紫色，用于信息存储、显示和照明等应用。激光波长的选择取决于具体应用的需求以及所使用的材料。 4激光照射宽度是指激光束在目标表面上的照射直径。激光束的照射宽度与激光器的发散角度、透镜系统等因素有关。通常情况下，激光照射宽度可以通过适当设计光学系统来控制和调整，以满足不同应用场景的需要。例如，在激光切割和焊接过程中，需要控制激光束的照射宽度和能量密度，以确保材料切割或焊接的质量和效率；在激光医疗领域，需要控制激光照射宽度和能量密度，以避免对周围组织的伤害。因此，在不同的应用场景中，激光照射宽度和能量密度的选择非常重要 5激光照射宽度的计算公式主要涉及激光束发散角、透镜的焦距以及目标距离等因素。以下是一个简单的计算公式：w = 2 * f * tan(θ/2) 直接拿上面公式计算其中，w为激光束在目标表面上的照射直径，f为透镜的焦距，θ为激光束的发散角。 需要注意的是，这个公式只是一个近似值，实际计算时还需要考虑其他因素的影响，例如激光束在传输过程中的衰减、大气折射等。因此，在实际应用中，最好根据具体情况进行现场测试和调整。","categories":[],"tags":[]},{"title":"图像形状特征","slug":"图像形状特征","date":"2023-03-29T08:33:27.000Z","updated":"2023-03-29T08:37:56.065Z","comments":true,"path":"2023/03/29/图像形状特征/","link":"","permalink":"http://example.com/2023/03/29/%E5%9B%BE%E5%83%8F%E5%BD%A2%E7%8A%B6%E7%89%B9%E5%BE%81/","excerpt":"","text":"常见的图像形状特征包括： 轮廓面积：物体轮廓的面积，可以用来表示物体的大小。矩：可以通过轮廓计算得到，用于描述物体的几何形状、面积、重心等特征。离心率：表示物体轮廓的长短轴比，用于描述物体的形状。形状因子：是指一个用来描述物体形状的无量纲量，可以用来区分不同形状的物体。椭圆度：物体轮廓与椭圆的匹配度，可以用来描述物体的形状。连通性：描述物体轮廓是否是连通的，可以用来区分不同的物体。轮廓长度：物体轮廓的长度，可以用来表示物体的周长。凸包：描述物体轮廓的最小凸多边形，可以用来表示物体的形状。等高线：用于描述物体轮廓的等高线曲线，可以用来表示物体的形状。方向直方图：描述物体轮廓的方向分布，可以用于物体识别和分类。","categories":[],"tags":[]},{"title":"c++简单面试题","slug":"c-简单面试题","date":"2023-03-28T02:12:53.000Z","updated":"2023-03-28T09:42:06.922Z","comments":true,"path":"2023/03/28/c-简单面试题/","link":"","permalink":"http://example.com/2023/03/28/c-%E7%AE%80%E5%8D%95%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"记录问题 char，short，int，double ,float ，long各占几个字节1234 虚函数和纯虚函数？ 重载函数和重载操作符 指针的大小123456789101112131415161718192021222324c++中，指针是指向一个变量地址，是存放变量地址，可以通过指针来访问内存中的数据。不管指向的变量是什么类型，一般在32bit下是4个字节，64bit下8个字节，16bit下2个字节。eg: int *ptr=NULL; std::cout&lt;&lt;&quot;test&quot;&lt;&lt;std::endl; std::cout&lt;&lt;&quot;ptr \\n&quot;&lt;&lt;sizeof(*ptr)&lt;&lt;std::endl; delete ptr; ptr=NULL;可以通过取地址符&amp;获取变量的地址eg： int a=10; int *ptr1=&amp;a; std::cout&lt;&lt;&quot;ptr1 \\n&quot;&lt;&lt;*ptr1&lt;&lt;std::endl; delete ptr1; ptr1=NULL;对指针进行加、减、递增和递减等算术运算 int A[64]=&#123;1,2,3,4,5,6,7,8&#125;; int *index=A; index++; //*index 指向第二个A[1],未加之前指向A[0]需要注意的是，指针算术运算的结果是一个指针类型的值，而不是指向某个特定变量的地址。，在进行指针算术运算时需要注意指针是否越界或者指向无效的内存位置C++中的指针指向的是内存地址，具体来说，它存储的是该内存块的首地址 类指针和指针类 菱形继承vs安装从高版本2022安装vs2010 版本向下兼容","categories":[],"tags":[]},{"title":"eigen矩阵取子矩阵","slug":"eigen矩阵取子矩阵","date":"2023-03-07T02:51:00.000Z","updated":"2023-03-07T06:39:01.814Z","comments":true,"path":"2023/03/07/eigen矩阵取子矩阵/","link":"","permalink":"http://example.com/2023/03/07/eigen%E7%9F%A9%E9%98%B5%E5%8F%96%E5%AD%90%E7%9F%A9%E9%98%B5/","excerpt":"","text":"子矩阵操作12345678matrix.col(i);//取第i列元素matrix.row(j);//取第i行元素matrix.block(i,j,p,q)；//提取块大小（p,q）初始目标位置（i,j）","categories":[],"tags":[{"name":"eigen","slug":"eigen","permalink":"http://example.com/tags/eigen/"}]},{"title":"二维数组转为eigen中矩阵","slug":"二维数组转为eigen中矩阵","date":"2023-03-07T01:14:51.000Z","updated":"2023-03-07T01:40:34.774Z","comments":true,"path":"2023/03/07/二维数组转为eigen中矩阵/","link":"","permalink":"http://example.com/2023/03/07/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BAeigen%E4%B8%AD%E7%9F%A9%E9%98%B5/","excerpt":"","text":"eigen 学习笔记MatrixXd12345在eigen中矩阵默认是列优先，而向量VectorXd只能是列优先，而重载&quot;&lt;&lt;&quot;操作符是一行，一行输入；矩阵元素的访问可以通过&quot;()&quot;操作符完成。eg: Eigen::MatrixXd Data(4,4);//定义一个4*4大小的矩阵 int a=3； Data（2，3）=a;//将Data矩阵2行3列赋值为3； 二维数组转为eigen的matrixXd 矩阵1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;Eigen/Dense&gt;int main()&#123; double parameter[5][4]=&#123;&#123;1,2,3,4&#125;, &#123;6,7,8,9&#125;, &#123;10,11,12,13&#125;, &#123;14,15,16,17&#125;, &#123;18,19,20,21&#125;&#125;; Eigin::MatrixXd Data(5,4); for(int i=0;i&lt;5;i++) &#123; for(int j=0;j&lt;4;j++) &#123; Data(5,4)=parameter[i][j]; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"回归分析","slug":"线性分析","date":"2023-02-28T06:44:34.000Z","updated":"2023-02-28T09:41:50.004Z","comments":true,"path":"2023/02/28/线性分析/","link":"","permalink":"http://example.com/2023/02/28/%E7%BA%BF%E6%80%A7%E5%88%86%E6%9E%90/","excerpt":"","text":"回归分析 相关分析是研究两个或两个以上的变量之间相关程度及大小的一种统计方法回归分析是寻找存在相关关系的变量间的数学表达式，并进行统计推断的一种统计方法 对回归分析进行分类，主要： 123根据变量的数目，可分为一元回归，多元回归根据自变量与因变量的表现形式，分为线性与非线性（构建出回归方程） 回归分析的一般步骤（大致上） 123451.确定回归分析中自变量与因变量2.确定回归模型3.建立回归方程4.对回归方程进行各种检验5.利用回归方程进行预测 一元线性回归分析 x：自变量，y：因变量 对具有线性关系的两个变量，可以用一个表达式（方程）来表达它们之间的线性关系 描述：因变量y与自变量x和误差e 的表达式成 回归方程 只涉及到一个自变量x的一元线性回归模型为：y=a1+a2x+e a1 为截距，a2 为斜率 e 为误差项，反应除x和y之间线性关系之外随机因素对y的影响 1234eg:人均收入是否显著影响人均食品消费支出贷款余额是否会影响到不良贷款航班正点率是否对顾客投诉次数有显著影响 根据对一元线性回归模型的假设，得到其回归方程：E(y)=a1+a2x 当回归方程的参数已知，对于给定x值，利用回归方程就能计算y的期望值 用样本统计量代替回归方程的未知参数，就得到估计的回归方程，简称回归直线 参数的最小二乘法估计 对于回归直线，关键在于求解参数，常用最小二乘法，是使因变量y和估计值之间的离差平方达到最小求解","categories":[],"tags":[]},{"title":"visdom远程启动","slug":"visdom远程启动","date":"2023-02-16T09:32:29.000Z","updated":"2023-02-16T09:46:04.373Z","comments":true,"path":"2023/02/16/visdom远程启动/","link":"","permalink":"http://example.com/2023/02/16/visdom%E8%BF%9C%E7%A8%8B%E5%90%AF%E5%8A%A8/","excerpt":"","text":"pytracking 配置问题（1）服务器远程连接 ssh 连接服务器 12345运行命令：ssh -L &lt;本地端口&gt;：localhost:8097 -p &lt;ssh访问服务器的端口号&gt; &lt;服务器名&gt;@&lt;ssh 服务器ip&gt;本地端口可以任意指定ssh -L 8000:localhost:8097 -p 12686 nwpu1@s3.z100.vip visdom 启动 12visdompython -m visdom.server 本地访问服务器可视化visdom 12阅览器localhost:&lt;设定本地端口&gt;","categories":[],"tags":[]},{"title":"opencl-笔记1","slug":"opencl-笔记1","date":"2023-01-30T08:39:03.000Z","updated":"2023-01-31T09:14:59.451Z","comments":true,"path":"2023/01/30/opencl-笔记1/","link":"","permalink":"http://example.com/2023/01/30/opencl-%E7%AC%94%E8%AE%B01/","excerpt":"","text":"1.安装vcpkg在Windows下开发C++程序时，Vcpkg是一个命令行包管理工具，极大地简化三方库的获取、安装、使用和部署流程。","categories":[],"tags":[]},{"title":"c++笔记","slug":"c-笔记","date":"2023-01-29T08:21:02.000Z","updated":"2023-02-16T09:33:48.290Z","comments":true,"path":"2023/01/29/c-笔记/","link":"","permalink":"http://example.com/2023/01/29/c-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"c++ 高性能服务器1234567891011121314151617181920212223开发环境（centos7， gcc 9.1（支持c++11 17））（4.9）项目路径bin --- 二进制文件build --中间文件路径cmake --cmake函数文件夹CMakeList.txt --CMake定义文件夹Makefilestylar --源码test ==测试代码日志系统 -- log4j logger（定义日志类别） | formatter （日志格式） | Appender （日志输出的地方） （logger server） （基于协程库封装）socket函数库http协议开发封装分布式协议推荐系统 ####log.h 1234567891011121314头件的中的#ifndef，有两个C文件，这两个C文件都include了同一个头文件。而编译时，这两个C文件要一同编译成一个可运行文件大量的声明冲突时。 把头文件的内容都放在#ifndef和#endif中。不管头文件会不会被多个文件引用，都要加上这个。：标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h #ifndef _STDIO_H_ #define _STDIO_H_ ...... #endif 智能指针多态性和虚函数内存分配内存对齐","categories":[],"tags":[]},{"title":"知识图谱","slug":"知识图谱","date":"2022-11-16T06:45:09.000Z","updated":"2022-11-19T01:29:46.237Z","comments":true,"path":"2022/11/16/知识图谱/","link":"","permalink":"http://example.com/2022/11/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/","excerpt":"","text":"知识图谱知识图谱旨在利用图结构建模，识别和推断事物之间的复杂关联关系和沉淀领域知识，是实现认知智能的重要基石，已经被广泛应用于搜索引擎，智能问答，语言语义理解，大数据决策分析，智能物联等众多领域。 知识图谱技术源于互联网，最早+","categories":[],"tags":[]},{"title":"微信小程序-6","slug":"微信小程序-6","date":"2022-11-16T06:42:19.000Z","updated":"2022-12-15T06:57:31.248Z","comments":true,"path":"2022/11/16/微信小程序-6/","link":"","permalink":"http://example.com/2022/11/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-6/","excerpt":"","text":"1. 条件渲染在小程序中，使用wx:if=”“来判断是否需要渲染该代码块：","categories":[],"tags":[]},{"title":"微信小程序-5","slug":"微信小程序-5","date":"2022-11-15T07:32:45.000Z","updated":"2022-11-16T06:37:36.285Z","comments":true,"path":"2022/11/15/微信小程序-5/","link":"","permalink":"http://example.com/2022/11/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-5/","excerpt":"","text":"WXML 模板语法1.数据绑定123456基本原则1.在data中定义数据2.在WXML中使用数据在data中定义页面的数据在页面对应的.js文件中，把数据定义到data对象中即可： 把data中的数据绑定到页面中渲染，使用Mustache语法将变量包起来即可。语法格式为： 1&lt;view&gt;&#123;&#123;要绑定的数据名称&#125;&#125;&lt;/view&gt; 实际代码 123456789101112131415161718-----.js----Page(&#123; /** * 页面的初始数据 */ data:&#123; //字符串类型 info: &#x27;string data&#x27;, //数组类型的数据 msgList:[&#123;msg: &#x27;hello&#x27;&#125;,&#123;msg: &#x27;world&#x27;&#125;] &#125;,&#125;&#125;------ .wxml----&lt;view&gt;&#123;&#123;info&#125;&#125;&lt;/view&gt; 1.1 Mustache 语法的应用场景 绑定内容 绑定属性 运算(三元运算，算术运算) 123456789101112---动态绑定属性----.js---Page(&#123; data: &#123; imgSrc: &#x27;https://t7.baidu.com/it/u=848096684,3883475370&amp;fm=193&amp;f=GIF&#x27; &#125;&#125;)---.wxml---&lt;image src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt;&lt;/image&gt; 三元运算 123456789---.js---Page(&#123; data: &#123; randomNum: Math.random()*10 //生成10以内的随机数 &#125;&#125;)----.wxml---&lt;view&gt;&#123;&#123;randomNum &gt;= 5 ? &#x27;随机数字大于或等于5&#x27; : &#x27;随机数字小于5&#x27;&#125;&#125;&lt;/view&gt; 算数运算 12345678910---.js--Page(&#123; data: &#123; randomNum: Math.random().toFixed(2) //生成一个带两位小数的随机数 &#125;&#125;)---.wxml--&lt;view&gt;生成100以内的随机数：&#123;&#123;randomNum *100&#125;&#125;&lt;/view&gt; 事件绑定事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务处理。 事件对象的属性列表当事件回调触发的时候，会收到一个事件对象event： target和currentTarget的区别 1234567target是触发该事件的源头组件，而currentTarget则是当前事件所绑定的组件。----.wxml---&lt;view class=&quot;outer-view&quot; bindtap=&quot;outerHandler&quot;&gt;//定义一个按钮 &lt;button type=&quot;primary&quot;&gt;按钮&lt;/button&gt;&lt;/view&gt; 点击内部按钮时，点击事件以冒泡的方式向外扩散，也会触发外层view的tap事件处理函数。 对于外层view: e.target指向的是触发事件的源头组件,因此,e.target是内部的按钮组件 e.currentTarget指向的是当前正在触发事件的那个组件，因此,e.currentTarge是当前view组件 bindtap 的语法格式在小程序，不存在HTML中的onclick鼠标点击事件，是通过tap事件来响应用户的触摸行为。 1234567891011121. 通过bindtap，可以为组件绑定tap触摸事件----.wxml---&lt;button type=&quot;primary &quot; bindtap=&quot;btnTapHandler&quot;&gt;按钮&lt;/button&gt;2.在,js文件中定义对应的事件处理函数，事件参数通过形参event(一般简写成e)来接受---.js----Page(&#123; btnTapHandler(event)&#123;//按钮的tap事件处理函数 console.log(event)//打印event属性 &#125;,&#125;) 在事件处理函数中为data中的数据赋值 123456789101112131415161718通过调用this.setData(dataObject)方法，可以给页面data中数据重新赋值---.js---Page(&#123; data: &#123; count: 0 &#125;, //修改count值 +1 CountChange()&#123; this.setData(&#123; count: this.data.count+1 &#125;) &#125;&#125;)----.wxml&lt;button type=&quot;primary&quot; bindtap=&quot;CountChange&quot;&gt;+1&lt;/button&gt; 事件传参 1234567891011121314151617181920小程序的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数，如下代码不能正常工作&lt;button type=&quot;primary&quot; bindtap=&#x27;btnHandler(123)&#x27;事件传参&lt;/button&gt;因为小程序会把bindtap的属性值，统一当作事件名称处理，相当于要调用一个名称为btnHandler(123)的事件处理函数可以为组件提供data-* 自定义属性传参，其中*代表的是参数的名字&lt;button bindtap=&quot;bynHandler&quot; data-info=&quot;&#123;&#123;2&#125;&#125;&quot;&gt;事件传参&lt;/button&gt;info会解析为参数的名字数值2 会被解析为参数的值在事件处理函数中，通过event.target.dataset.参数名，即可获取到具体参数值 bynHandle(event)&#123; console.log(event.target.dataset), console.log(event.target.dataset.info) &#125;, btnADD2(event)&#123; this.setData(&#123;count:this.data.count+event.target.dataset.info&#125;)//count +2 &#125;, bindinput 的语法格式 123456789101112通过input事件来响应文本框的输入事件：1. 通过bindinput，文本框绑定输入事件---.wxml&lt;input bindinput=&quot;inputHandler&quot;&gt;&lt;/input&gt;2.在.js中定义事件处理函数inputHandler(event)&#123; //event.detail.value是变化后，文本框最新值 console.log(event.edtail.value)&#125; 实现文本框和data之间的数据同步 123456789101112131415161718192021222324252627282930313233343536实现步骤1.定义数据2.渲染结构3.美化样式4.绑定input事件处理函数定义数据----.js--Page(&#123; data: &#123; msg: &#x27;你好，&#x27; &#125;&#125;)渲染结构---.wxml---&lt;input value=&quot;&#123;&#123;msg&#125;&#125;&quot; bindinput= &quot;iptHandler&quot;&gt;&lt;/input&gt;美化样式结构---.wxcs---input&#123; border: 1px solid #eee; padding: 5px; margin: 5px; border-radius: 3px;&#125;绑定input事件处理函数iptHandler(event)&#123; this.setData(&#123; msg: event.detail.value &#125;)&#125;","categories":[],"tags":[]},{"title":"微信小程序-4","slug":"微信小程序-4","date":"2022-11-14T09:54:57.000Z","updated":"2022-11-15T07:32:01.174Z","comments":true,"path":"2022/11/14/微信小程序-4/","link":"","permalink":"http://example.com/2022/11/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-4/","excerpt":"","text":"小程序API小程序API调用微信提供的能力，如获取用户信息，本地存储，支付功能 123456789101112131415API大致分成三类1.事件监听API 以on开头，用来监听某些事件的触发 wx.onWindowResize(function callback)监听窗口尺寸变化的事件2.同步API以Sync结尾API都是同步API 同步API的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常 wx.setStorageSync（&#x27;Key&#x27;,&#x27;value&#x27;）向本地存储中写入内容3.异步API 类似于JQuery中$.ajax(options)函数,需要通过success,fail，complete接收调用的结果 wx.request()发起网络数据请求，通过success回调函数接受数据 协调工作要求干啥就干啥 123456781.项目成员 参与小程序开发，运营成员 可登陆小程序管理后台 管理员可以添加，删除项目成员，并设置项目成员的角色2. 体验成员 参与小程序内测体验的成员 可使用体验版小程序，但不属于项目成员 管理员及项目成员均可添加，删除体验成员 小程序发布上线一般经过上传代码-&gt;审核代码-&gt;发布 上传代码121. 点击开发者工具中工具栏的“上传”按钮2. 填写版本号以及项目备注 登陆小程序管理后台-&gt;管理-&gt;版本管理-&gt;开发版本，即可以查看上传版本 为了保证小程序的质量，以及符合相关规定，小程序的发布是需要经过腾讯官网审核的。 1在开发版本的列表中，点击“提交审核”按钮之后，按照页面提示填写相关信息，就把小程序提交到腾讯官方审核。 发布审核通过后，管理员的微信中会收到小程序通过审核的通知，在审核版本的列表中，点击“发布”按钮，即可把“审核通过”的版本发布为“线上版本”，供所有小程序用户访问和使用 获取小程序码登陆小程序管理后台-&gt;设置-&gt;基本设置-&gt;基本信息-&gt;小程序码及线下物料下载 查看运营数据12345671.在“小程序后台”查看 登陆小程序管理后台 点击侧边栏的“统计” 点击相应的tab可以看到相关的数据2.使用“小程序数据助手”查看 在微信中搜索“小程序数据助手” 查看已发布的小程序相关的数据","categories":[],"tags":[]},{"title":"微信小程序-3","slug":"微信小程序-3","date":"2022-11-14T01:57:15.000Z","updated":"2022-11-14T09:51:13.722Z","comments":true,"path":"2022/11/14/微信小程序-3/","link":"","permalink":"http://example.com/2022/11/14/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-3/","excerpt":"","text":"1.小程序中组件的分类12345678910小程序中的组件也是由宿主环境提供的，基于组件快速搭建出页面结构，主要分成9大类1.视图容器2.基础内容3.表单组件4.导航组件5.媒体组件6.map地图组件7.canvas画布组件8.开放能力9.无障碍访问 1.1 常用的视图容器类组件 view 123普通视图区域类似于HTML中div，是一个块级元素常用来实现页面的布局效果 list.wxml 12345&lt;view class=&quot;containerListBottom&quot;&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt;&lt;/view&gt; list.wxss 12345678910111213141516171819containerListBottom view&#123; width: 100px; height: 100px; text-align: center; line-height: 100px;&#125;.containerListBottom view:nth-child(1)&#123; background-color: lightseagreen;&#125;.containerListBottom view:nth-child(2)&#123; background-color: lightsalmon;&#125;.containerListBottom view:nth-child(3)&#123; background-color: limegreen;&#125;.containerListBottom&#123; display: flex; justify-content: space-around;&#125; scroll-view 12可滚动的视图区域常用来实现滚动列表效果 list.wxml 12345&lt;scroll-view class=&quot;containerListscroll&quot;scroll-y&gt; &lt;view&gt;D&lt;/view&gt; &lt;view&gt;E&lt;/view&gt; &lt;view&gt;F&lt;/view&gt;&lt;/scroll-view&gt; list.wxcs 1234567891011121314151617181920212223242526272829.containerListscroll view&#123; width: 100px; height: 100px; text-align: center; line-height: 100px;&#125;.containerListscroll view:nth-child(1)&#123; background-color: limegreen;&#125;.containerListscroll view:nth-child(2)&#123; background-color: magenta;&#125;.containerListscroll view:nth-child(3)&#123; background-color: mediumslateblue;&#125;.containerListscroll&#123; /*给scroll view 固定高度*/ border: 1px solid lightsteelblue; height: 120px; width: 100px;&#125; swiper和swiper-item 1轮播图容器组件和轮播图item组件 1.2 view组件的使用 1.3 Scroll-view 组件使用 123scroll-y :允许纵向滚动scroll-x :允许横向滚动在使用纵向滚动时，需要给scroll-view一个固定高度 1.4 swiper和swiper-item组件的基本使用 list.wxml 12345678910111213indicator-dots :显示面板指示点代码如下&lt;swiper class =&quot;push_bottom&quot; indicator-dots&gt; &lt;swiper-item&gt; &lt;view class =&quot;test&quot;&gt;A&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class =&quot;test&quot;&gt;B&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class =&quot;test&quot;&gt;C&lt;/view&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; list.wxcs 1234567891011121314151617181920212223.push_bottom&#123; height: 150px;&#125;.test&#123; height: 100%; line-height: 100px; text-align: center;&#125;/*.test前面得有一个空格才显示的*/(很奇怪)swiper-item:nth-child(1) .test&#123; background-color: limegreen;&#125;swiper-item:nth-child(2) .test&#123; background-color: limegreen;&#125;swiper-item:nth-child(3) .test&#123; background-color: limegreen;&#125; 1.5 swiper 组件的常用属性 1&lt;swiper class =&quot;push_bottom&quot; indicator-dots indicator-color=&quot;red&quot; indicator-active-color=&quot;blue&quot; autoplay=&quot;true&quot; interval=&quot;2500&quot; circular=&quot;true&quot;&gt; 1.6 基础内容组件text 123文本组件类似于HTML中span标签，是一个行内元素 rich-text 12富文本组件支持把HTML字符串渲染为WXML结构 1.6.1 text组件的使用通过text 组件的selectable属性，实现长按选中文本内容效果： 12345---list.wxml---&lt;view&gt; 手机号支持长度选中效果 &lt;text selectable&gt;13092811271&lt;/text&gt;&lt;/view&gt; 1.6.2 rich-text 组件的使用通过rich-text组件的nodes属性节点，把HTML字符串渲染为对应的UI结构 12---list.wxml&lt;rich-text nodes=&quot;&lt;h1 style=&#x27;color: green;&#x27;&gt;商品&lt;/h1&gt;&quot;&gt;&lt;/rich-text&gt; 1.7 其他常用组件 button 123按钮组件功能比HTML中button按钮丰富通过open-type属性可以调用微信提供的各种功能(客服，转发，获取用户授权，获取用户信息的等) image 12图片组件image组件默认宽度约为300px，高度240px navigator 12页面导航组件类似于HTML中的a链接 1.7.1 button 按钮使用1234567891011121314151617-----list.wxml&lt;view&gt;-----通过type指定按钮类型-----&lt;/view&gt;&lt;button&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warm&quot;&gt;警告按钮&lt;/button&gt;&lt;view&gt;--------size=&quot;mini-------&quot;&lt;/view&gt;&lt;button size=&quot;mini&quot;&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; size=&quot;mini&quot;&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warn&quot; size=&quot;mini&quot;&gt;警告按钮&lt;/button&gt;&lt;view&gt;--------plain 镂空按钮&lt;/view&gt;&lt;button size=&quot;mini&quot; plain&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; size=&quot;mini&quot; size=&quot;mini&quot; plain&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warn&quot; size=&quot;mini&quot; plain&gt;警告按钮&lt;/button&gt; 1.7.2 image组件的基本使用12345678910111213---list.wxml&lt;image&gt;&lt;/image&gt;&lt;image src=&quot;/image/1.jpg&quot;&gt;&lt;/image&gt;----list.wxcsimage&#123; border: 1px solid red;&#125; 1.7.3 image组件mode属性image组件的mode属性用来指定图片的裁剪和缩放模式，常用mode属性值如下： 12&lt;image src=&quot;/image/1.jpg&quot; mode=&quot;aspectFit&quot;&gt;&lt;/image&gt;&lt;image src=&quot;/image/1.jpg&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;","categories":[],"tags":[]},{"title":"微信小程序-2","slug":"微信小程序-2","date":"2022-11-12T08:25:36.000Z","updated":"2022-11-14T01:33:43.260Z","comments":true,"path":"2022/11/12/微信小程序-2/","link":"","permalink":"http://example.com/2022/11/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-2/","excerpt":"","text":"小程序的宿主环境宿主环境 12宿主环境（host environment）指的是程序运行所必须的依赖环境，脱离了宿主环境的软件没有任何意义。而手机微信是小程序的宿主环境，小程序借助宿主环境提供的能力，可以完成普通网页无法完成的功能。微信扫码，微信支付，微信登陆，地理定位，etc 小程序宿主环境包含的内容 1234通信模型运行机制组件API 通信模型1. 通信的主体123小程序中通信的主体是渲染层和逻辑层：WXML模板和WXSS样式工作在渲染层JS脚本工作在逻辑层 2.小程序的通信模型123小程序中的通信模型分成两个部分渲染层和逻辑之间的通信（由微信客户端进行转发）逻辑层和第三方服务器之间的通信（微信客户端进行转发） 3.小程序运行机制3.1 小程序启动过程123451.把小程序的代码包下载到本地2.解析app.json 全局配置文件3.执行app.json小程序入口文件，调用APP()创建小程序实例4.渲染小程序首页5.小程序启动完成 3.2 页面渲染的过程12341.加载解析页面的.json配置文件2.加载页面的.vxml模板和.wxSS样式3.执行页面的.js文件,调用page()创建页面实例4.页面渲染完成","categories":[],"tags":[]},{"title":"微信小程序-1","slug":"微信小程序-1","date":"2022-11-11T08:11:17.000Z","updated":"2022-11-21T03:27:55.548Z","comments":true,"path":"2022/11/11/微信小程序-1/","link":"","permalink":"http://example.com/2022/11/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-1/","excerpt":"","text":"微信小程序微信小程序运行在微信环境中，有自己的一套标准开发模式 1234567申请小程序开发账户安装小程序开发者工具创建和配置小程序项目由于运行环境的不同，小程序中，无法调用DOM和BOM的API，但小程序可以调用微信环境提供的各种APIeg：地理定位 扫码 支付 123小程序页面的组成部分所有小程序的页面，都存放在pages 目录中，以单独的文件夹存在 index存放索引log 存放日志其中，每个页面由4个基本文件组成，分别是：.js文件（页面的脚本文件，存放页面的数据，事件处理函数等）.json文件（当前页面的配置文件，配置窗口的外观，表现等）.wxml文件（页面的模板结构文件）（标签）.wxss文件（当前页面的样式表文件） 1JSON配置文件的作用 JSON是一种数据格式，在实际开发中，JSON总以配置文件的形式出现，通过不同的.json配置文件，可以对小程序项目进行不同级别的配置。小程序项目中由4种json配置文件项目根目录的app.json配置文件项目根目录种project.config.json配置文件项目根目录种的sitemap.json配置文件每个页面文件夹中的.json配置文件 1app.json文件 app.json是当前小程序的全局配置，包括小程序的所有页面路径，窗口外观，界面表现，底部tab等在项目中app.json配置：pages：用来记录当前小程序所有页面的路径window：全局定义小程序所有页面的背景色，文字颜色等style:全局定义小程序组件所使用的样式版本sitemapLocation：用来指明sitemap.json的位置 1project.config.json文件 project.config.json 是项目配置文件,小程序开发工具的个性化配置 setting中保存了编译相关的配置projectname中保存的是项目名称appid保存的小程序的账号ID 1sitemap.json文件 微信已开放小程序内搜索，类似PC网页的SEO，sitemap.json文件来配置小程序页面是否允许微信索引。当允许微信索引时，微信会通过爬虫的形式，为小程序的页面建立索引，当用户的搜素关键字和页面的索引匹配成功时，小程序的页面将可能展示在搜素结果中。 sitemap的索引提示是默认开启，如需要关闭sitemap的索引提示，可在小程序项目配置文件project.config.json 的setting 中配置字段checkSiteMap为false。如果没有，手动添加 “checkSiteMap”: true, 1页面的.json配置文件 小程序中每个页面，可以使用.json文件来对本页面的窗口外观配置，页面中的配置项会覆盖app.json的window中相同的配置项。eg.在pages目录下的index,json中添加 “navigationBarBackgroundColor”: “#00FA9A”当全局配置与页面配置冲突时，以页面配置为主 1新建小程序页面 在app.json-&gt;pages中新增页面的存放路径，小程序开发者工具可帮助自动创建对应的页面文件 eg：在pages项中添加 “pages/list/list” 1修改项目首页 只要调整app.json-&gt;pages 数组中页面路径的前后顺序，即可修改项目首页。小程序会把排在第一位的页面，当作项目首页进行渲染 1WXML WXML(WeiXin Markup Language)是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作用类似于网页开发中HTML。WXML与HTML的区别标签不同HTML (div(布局),sapn（文本）,img,a（行跳转）)WXML(view（布局）,text（文本）,image,navigator)属性节点不同 &lt;a href =&quot;#&quot;&gt;超链接&lt;/a&gt; &lt;navigator url=&quot;/pages/home/home&quot;&gt;&lt;/navigator&gt; 提供了类似Vue中的模板语法 数据绑定列表渲染条件渲染 123WXSS WXCC(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式，类似于网页开发中css。WXSS和CSS区别：新增了rpx尺寸单位CSS中需要手动进行像素单位换算，例如remWxss在底层支持新的尺寸单位rpx，在不同大小的屏幕上小程序会自动进行换算。 提供了全局的样式和局部样式项目中根目录app.wxss会作用于所有小程序页面局部页面的.wxss样式仅对当前页面生效 WXss仅支持部分CSS选择器.class 和#idelement并集选择器，后代选择器::after和::before等伪类选择器 1小程序中.js文件 一个项目仅仅提供界面展示是不够的，在小程序中，通过.js文件来处理用户的操作。eg:响应用户的点击，获取用户的位置等JS文件分成三大类：app.js 是整个小程序项目的入口文件，通过调用APP()函数来启动整个小程序页面的.js文件 是页面的入口文件，通过调用Page（）函数来创建并运行页面 普通的.js文件 是普通的功能模块文件，用来封装公共的函数或属性供页面使用```","categories":[],"tags":[]},{"title":"makefile-笔记","slug":"makefile-笔记","date":"2022-10-24T06:33:16.000Z","updated":"2022-11-14T01:45:11.554Z","comments":true,"path":"2022/10/24/makefile-笔记/","link":"","permalink":"http://example.com/2022/10/24/makefile-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"{1.快速编译基础，2.生成多个程序的Makefile 3. 生成驱动模块的Makefile} 1. 快速编译基础makefile生成可执行程序 - make脚本生成多个可执行文件 make 工程管理器，也称“自动编译管理器” 读入Makefile文件编辑内容来执行具体编译工作 根据文件时间戳自动发现更新过的文件 只编译改动的代码文件，而不用完全编译 1234567Makefile 是 Make 读入的唯一配置文件target:dependency_files(依赖)&lt;TAB&gt;command例如：hello.o : hello.c hello.h gcc -c hello.c -o hello.o 由make工具创建的目标体（target），通常是目标文件或可执行文件 要创建的目标体所依赖的文件（dependency_file） 创建每个目标体时需要运行的命令(command) 命令行前面必须是一个“TAB键”，否则编译错误为：***missing sepaeator.Stop 12345678910Makefile 基础版格式test: f1.o f2.o main.o gcc f1.o f2.o main.o -o testmain.o: main.c head.h gcc -c -Wall main.c -o main.of1.o:f1.c gcc -c -Wall f1.c -o f1.of2.o:f2.c gcc -c -Wall f2.c -o f2.o Makefile 变量Make允许在Makefile中创建和使用变量，变量在Makefile中定义的一些名字，用来替代一个文本字符串，该文本字符串称为该变量的值 用户自定义变量/预定义变量/自动变量/环境变量 例如 src= fun1.c fun2.c 1$ 符号 调用 $(src) 调用src 自定义变量： 其值由用户自行设定，（变量的值可以用来代替目标体，依赖文件，命令以及Makefile文件中的其他部分） 两种方式 递归展开方式 123foo=$(bar)bar=$(ugh)ugh=Huh? 简单扩展方式 12345678m :=mmx :=$(x)bary:=$(x)barX:=later ‘+=’ 符号是在原有的基础上加上一个值（在原有基础上赋值添加）eg：A=a A+=b 等同于 A=a+b 自动变量：用于代表编译语句中出现的目标文件和依赖文件，具有本地含义 123456常见自动变量$&lt; 第一个依赖文件的名称$@ 目标文件的完整名称$^ 所有不重复的目标依赖文件，以空格分开$? 所有时间戳比目标文件晚的依赖文件，并以空格分开 预定义变量：预先定义的常见编译器，汇编器的名称及编译选项 123456CC C编译器的名称，默认值CC （gcc）RM 文件删除程序的名称，默认值为 rm -fCFLAGS C编译器的选项，无默认值AR 库文件维护程序的名称，默认值为arCPP C预编译器的名称，默认值为$(CC) -ECPPFLAGS C预编译的选项，无默认值 make clean 1234567891011用户可以在一个Makefile中定义一些和编译无关的命令，（程序的打包，备份和删除等）.PHONY 说明伪目标eg: Makefile 中添加如下.PHONY :cleanclean: -rm f1.o f2.o main.o test使用格式： make clean make 隐含规则 121: 编译C程序的隐含规则 &quot;&lt;n&gt;.o&quot; 目标的依赖目标会自动推导为&quot;&lt;n&gt;.c&quot;2: 链接Object文件的隐含规则&quot;&lt;n&gt;&quot;目标的依赖目标会自动推导为&quot;&lt;n&gt;.o&quot; 嵌套的makefile案例 123456789@echo $(SUBDIRS) 让ehco显示提示@(RM) 预定义变量， rm -fmake -C $@ 读入指定目录下的makefileexport CC OBJS BIN OBJS_DIR BIN_DIR 让子makefile可以找到使用这些变量 改进后的makefile 1234567OBJS=f1.o f2.o main.o //自定义变量（可以是c,也可以是O）CFLAGS= -c -O -g -Wall //gcc的参数main:$(OBJS).PHONY:claen //伪目标clean: -rm $(OBJS) main make 工具使用参数 123456789make 带选项-C dir读入指定目录下的Makefile （多个目录下多个makefile）-f file读入当前目录下的file文件作为Makefile-i 忽略所有的命令执行错误-l dir指定被包含的Makefile所在目录-n 只打印要执行的命令,但不执行这些命令(预演，检查功能)-P 显示make变量数据库和隐含规则-s 在执行命令时不显示命令-W 如果make在执行过程中改变目录，打印当前目录名 2 . 生成多个程序的Makefile all:server client //(all 来说明将生成的可执行程序/目标) 123456789101112131415CC=gcc //（可以不写）DEBUG= -g -O0 -WallCFLAGS += $(DEBUG)#设置创建文件规则，所有.c文件对应一个同名的无后缀文件(无.c后缀)OBJS=$&#123;patsubst %.c,%,$&#123;wildcard *.c&#125;&#125;//把当前目录下同名.c文件替换，不加.c# OBJS=server client#根据创建文件规则,利用默认编译规则产生可执行文件all:$(OBJS).PHONY:cleanclean: -rm -f *.o $(OBJS) core //命令前是tab键 3 生成驱动模块的Makefile12345678910111213141516171819202122232425262728ifeq($(KERNELRELEASE),)KERNELDIR？=目标板Linux内核源码顶层目录的绝对路径ROOTFS？=目标板根文件系统顶层目录的绝对路径//.ko文件是驱动文件PWD:=$(shell pwd)//列出当前路径（调用shell命令pwd）modules: make -C $(KERNELDIR) M=$(PWD)modulesmodules: make -C $(KERNELDIR)M=$(PWD)INSTALL_MOD_PATH=$(ROOTFS)modules_installclean: rm -rf *.o *.ko .*.cmd *.mod.* modules.order Module.symvers .tmp_versionselseobj-m += hello.o#用obj-m 来指定模块名,注意模块名加.o 而不是.ko, 与源码文件同名endif#obj-m += test.o#test-objs=test.o fun.o#用模块名 -objs变量 来指定编译到ko中的所有.0文件名 （每个同名的.c文件对应的.o目标文件） 升级版 1234567891011121314151617181920212223242526APP_NAME=hello_test//生成可执行文件的名字ifeq ($ (KERNELRELEASE),)ifeq($(ARCH),arm)KERNELDIR?=目标板linux内核源码顶层目录的绝对路径ROOTFS?=目标板根文件系统顶层目录的绝对路径CROSS_COMPILE=ubuntu上交叉工具链的绝对路径/gcc-4.6.4/bin/arm-none-linux-guneabicc=$(CROSS_COMPILE)gcc//板子上交叉工具的源码路径链elseKERNELDIR?=/lib/modules/$(shell uname -r)/buildendifPWD:=$(shell pwd)modules: $(MAKE) -C $(KERNELDIR) M=$(PWD)modules $(cc)$(APP_NAME).c -o $(APP_NAME)//调用交叉工具链modules_install: $(MAKE) -C $(KERNELIR)M=%(PWD)INSTALL_MOD_PATH=$(ROOTFS)modules_installclean: $(MAKE) -C %(KERNEL_DIR)M=$(CUR_DIR)cleanelseobj-m +=hello.oendif http://www.gnu.org/software/","categories":[],"tags":[]},{"title":"c++笔记-1","slug":"c-笔记-1","date":"2022-10-22T01:41:48.000Z","updated":"2022-10-24T10:06:52.703Z","comments":true,"path":"2022/10/22/c-笔记-1/","link":"","permalink":"http://example.com/2022/10/22/c-%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"系统性能靠offload（）代码质量靠Clang() Q1 如果现在重写muduo 会改那些设计？ Q2 Muduo 原来是用std::function 相当于多态。现在是否可以用concept 和 template来减少性能开销？ FFmpeg 硬件加速 12345678H.264和 vp9 AV1 google -&gt;vcu,cpu,nvidia GPUGPU 加速浮点（向量）运算TPU 加速矩阵乘法VCU 加速视频压缩 Q3 商业的代码检查工具1234567891011121314151617181920212223Effective C+++emplace() vs push_back()?Q4 当析构函数遇到多线程中 ：对象的销毁太难了，c++11后是否已经有更好的解决方案？c++17以后Q5 用std::thread创建线程，是否有助于解决问题？Q6 std::thread的生命周期与销毁？Q7 面试被问到为什么要用muduo?MMuduo 谐音 mdoel Tanenbaum：MinixMFCLite3https//www.youtube.com/c/ShuoChenclangd c++后端(音视频)```markdown c++ 1.c/c++ stl（vector，list，map，set，hashmap，iterator….） c++新特性 (lamda 智能指针) 2. Linux （epoll （网络协议（tcp/udp））服务器操作系统 ） （系统调用） (shell,gcc/g++/gdb,makefile,cmake,vscode (常识))) （Linux系统为应用开发提供哪些功能？） （cpu 0 占用率高 ？ （htop/top）） 当占用率100%，陷入死循环 ，加入条件等待 cpu1/cpu2 做cpu的亲缘性 linux 内核 （内存管理 ，程序运行（代码操作的虚拟内存（堆））-&gt; 进程（构建虚拟内存图），） 操作系统进入bios后，物理内存无法更改 (内存管理) （进程调度） （文件系统）VFS（open） | (ext3 ext4 tmpfs .....) 3. 网络 （网络编程）（1对n，多并发） （网络原理）（1对1网络传输） （tcp三次握手， 四次挥手 滑动窗口 慢启动 拥塞控制 ,udp （8个字节头） ,http(基于tcp的应用)（get/post/delete/head） https(sql注入)xss攻击） （c10K,c1000K，c10m 网络io模型 io 多路复用，select/poll/epoll,io_uring time_wait,close_wait 网络框架libevent,muduo ） 设计模式（纯经验 项目重构 项目立项之初） 4 数据库 持久化MySQL(curd,索引,事务，ACID) 缓存Redis MYSQL （源码）（不建议） （建议）Redis Nginx Memcahed 1.sql语句， 5.数据结构（11种排序 队列，栈，线性结构 树，二叉树,红黑树,b/b++tree 递归，二分查找 跳表，散列表，hash算法 字符串处理，KMP算法 图，dijkstra,最小生成树 贪心,动态规划 时间复杂度/空间复杂度） 6.分布式 rpc协议设计，protobuf/thrift 服务寻址，数据流的序列化与反序列化 一致性算法 主流的rpc，grpc，brpc，srpc，tars 服务注册，服务发现，zk/etcd 缓存击穿，缓存雪崩 容灾保护，降级熔断，流量控制 7.云原生 docker原理和搭建 K8s 容器编排 服务网格 8.软技能 unix环境高级编程 深度 -&gt;核心技能广度 -&gt;","categories":[],"tags":[]},{"title":"tx2笔记-1","slug":"tx2笔记-1","date":"2022-10-20T03:08:28.000Z","updated":"2022-11-14T01:46:28.347Z","comments":true,"path":"2022/10/20/tx2笔记-1/","link":"","permalink":"http://example.com/2022/10/20/tx2%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"TX2网络配置123456tx2 使用NetworkManager 进行网络管理 networking常用的一些的网络配置命令和目录sudo su (切换到root用户)sudo vim /etc/network/interfaces在其中修改网路配置 关键的参数一定要拼写正确 12345678910111213141516 1 # interfaces(5) file used by ifup(8) and ifdown(8) 2 # Include files from /etc/network/interfaces.d: 3 source-directory /etc/network/interfaces.d/* 4 #auto lo 5 #iface lo inet loopback 6 #auto eth0 7 8 #iface eth0 inet static 9 #address 192.168.10.100 //要ifconfig eth0 IP 一致10 11 #netmask 255.255.255.012 #gateway 192.168.10.118 // 13 #dns-nameserver 8.8.8.8 //DNS14 #nameserver 8.8.8.815 #nameserver 114.1114.114.114 重启网络服务 1sudo /etc/init.d/networking restart route 1route -n (查看网络配置情况) 修改DNS 12345sudo vim /etc/resolv.conf#######nameserver 8.8.8.8nameserver 192.168.10.100 网络配置常用的查询命令 12345678910----- systemctl----| status 状态 systemctl restart networkingsystemctl stop networkingsystemctl status networkingsystemctl status NetworkManager- serice ------service NetworkManager status 简单心得 12345tx2 网络配置不是很好用，直接在win10上 用Xshell ssh方式远程连接 、在windows 使用 arp -a 查看 wlan 端口 ip地址 （连接前后多出来的就是tx2 物理地址）后续测试一下网线(很坑的，尽量不用)刷新IPsudo ip addr flush wlan0","categories":[],"tags":[]},{"title":"Linux学习-9","slug":"Linux学习-9","date":"2022-10-19T07:33:38.000Z","updated":"2022-10-19T09:45:35.394Z","comments":true,"path":"2022/10/19/Linux学习-9/","link":"","permalink":"http://example.com/2022/10/19/Linux%E5%AD%A6%E4%B9%A0-9/","excerpt":"","text":"Linux 软件包管理1 RPMRPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。RPM包的名称格式Apache-1.3.23-11.i386.rpm “apache” 软件名称 “1.3.23-11”软件的版本号，主版本和此版本 “i386”是软件所运行的硬件平台，Intel 32位处理器的统称 “rpm”文件扩展名，代表RPM包 1.1 RPM 查询命令（rpm -qa） 基本语法12345678910111213141516171819由于软件包比较多，一般都会采取过滤。rpm -qa |grep rpm软件包rpm -qa （查询所安装的所有 rpm 软件包)- ------rpm -qa | grep firefox(查询firefox软件安装情况)#### 1.2 RPM 卸载命令- 基本语法```markdownrpm -e RPM软件包rpm -e --nodeps 软件-e 卸载软件包--nodeps 卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作rpm -e firefox 1.3 RPM 安装命令 基本语法123456789rpm -ivh RPM 包全名- i install 安装-v --verbose 显示详细信息-h --hash 进度条--nodeps 安装前不检查依赖rpm -ivh firefox-45.0.1-1.el6.centos.x86_64.rpm(安装firefox软件) 2 YUMYUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS中的 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装 2.1 YUM 的常用命令 基本语法123456789101112131415yum [选项] [参数]选项-y 对所有提问都回答“yes”参数install 安装 rpm 软件包update 更新 rpm 软件包check-update 检查是否有可用的更新 rpm 软件包remove 删除指定的 rpm 软件包list 显示软件包信息clean 清理 yum 过期的缓存deplist 显示 yum 软件包的所有依赖关yum -y install firefox (采用 yum 方式安装 firefox) 2.2 修改网络 YUM 源 默认的系统 YUM 源，需要连接国外 apache 网站，网速比较慢，可以修改关联的网络YUM 源为国内镜像的网站，比如网易 163,aliyun 等123456789101112131415161718191）安装 wget, wget 用来从指定的 URL 下载文件yum install wget2）在/etc/yum.repos.d/目录下，备份默认的 repos 文件cp CentOS-Base.repo CentOS-B3）下载网易 163 或者是 aliyun 的 repos 文件,任选其一wgethttp://mirrors.aliyun.com/repo/Centos-7.repo //阿里云wgethttp://mirrors.163.com/.help/CentOS7-Base-163.repo //网易 1634）使用下载好的 repos 文件替换默认的 repos 文件例如:用 CentOS7-Base-163.repo 替换 CentOS-Base.repomv CentOS7-Base-163.repo CentOS-Base.re5）清理旧缓存数据，缓存新数据yum clean allyum makecache(yum makecache 就是把服务器的包信息下载到本地电脑缓存起来)","categories":[],"tags":[]},{"title":"Linux学习-8","slug":"Linux学习-8","date":"2022-10-19T06:32:40.000Z","updated":"2022-10-19T07:32:20.315Z","comments":true,"path":"2022/10/19/Linux学习-8/","link":"","permalink":"http://example.com/2022/10/19/Linux%E5%AD%A6%E4%B9%A0-8/","excerpt":"","text":"1. Linux 进程管理进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。 1.1 ps 查看当前系统进程状态ps:process status 进程状态 基本语法 123456789101112131415161718192021222324252627282930313233343536373839404142434445ps aux | grep xxx （查看系统中所有进程）ps -ef | grep xxx （可以查看子父进程之间的关系）--------a 列出带有终端的所有用户的进程x 列出当前用户的所有进程，包括没有终端的进程u 面向用户友好的显示风格-e 列出所有进程-u 列出某个用户关联的所有进程-f 显示完整格式的进程列表------------（1）ps aux 显示信息说明USER： 该进程是由哪个用户产生的PID： 进程的 ID 号%CPU： 该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源；%MEM： 该进程占用物理内存的百分比，占用越高，进程越耗费资源；VSZ： 该进程占用虚拟内存的大小，单位 KB；RSS： 该进程占用实际物理内存的大小，单位 KB；TTY： 该进程是在哪个终端中运行的。对于 CentOS 来说，tty1 是图形化终端，tty2-tty6 是本地的字符界面终端。pts/0-255 代表虚拟终端。STAT： 进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、Z： 僵尸状态、s：包含子进程、l：多线程、+：前台显示START： 该进程的启动时间TIME： 该进程占用 CPU 的运算时间，注意不是系统时间COMMAND： 产生此进程的命令名（2）ps -ef 显示信息说明UID： 用户 IDPID： 进程 IDPPID： 父进程 IDC： CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高STIME： 进程启动的时间TTY： 完整的终端名称TIME： CPU 时间CMD： 启动进程所用的命令和参数----------如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux;如果想查看进程的父进程 ID 可以使用 ef;\\ ps aux (查看进程的 CPU 占用率和内存占用率) ps -ef (查看进程的父进程 ID) 1.2 kill 终止进程 基本语法 12345678kill [选项] 进程号 （通过进程号杀死进程）killall 进程名称 （通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）-9 表示强迫进程立即停止kill -9 5102 (杀死浏览器进程)killall firefox(通过进程名称杀死进程) 1.3 pstree 查看进程树 基本语法 12345678910pstree [选项]-p 显示进程的 PID-u 显示进程的所属用户---------pstree -p (显示进程 pid)pstree -u(显示进程所属用户) 1.4 top 实时监控系统进程状态 基本命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354top [选项]-d 秒数 指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当中可以执行的命令-i 使 top 不显示任何闲置或者僵死进程-p 通过指定监控进程 ID 来仅仅监控某个进程的状态操作说明P 以 CPU 使用率排序，默认就是此项M 以内存的使用率排序N 以 PID 排序q 退出 top查询结果字段解释第一行信息为任务队列信息12:26:46 系统当前时间up 1 day, 13:32 系统的运行时间，本机已经运行 1 天13 小时 32 分钟2 users 当前登录了两个用户load average: 0.00, 0.00, 0.00 系统在之前 1 分钟，5 分钟，15 分钟的平均负载。 一般认 为小于 1 时，负载较小。如果大于1，系统已经超出负荷第二行为进程信息 Tasks: 95 total 系统中的进程总数1 running 正在运行的进程数94 sleeping 睡眠的进程0 stopped 正在停止的进程0 zombie 僵尸进程。如果不是 0，需要手工检查僵尸 进程 第三行为 CPU 信息Cpu(s): 0.1%us 用户模式占用的 CPU 百分比0.1%sy 系统模式占用的 CPU 百分比0.0%ni 改变过优先级的用户进程占用的 CPU 百分比99.7%id 空闲 CPU 的 CPU 百分比0.1%wa 等待输入/输出的进程的占用 CPU 百分比0.0%hi 硬中断请求服务占用的 CPU 百分比0.1%si 软中断请求服务占用的 CPU 百分 0.0%st st（Steal time） 虚拟时间百分比。就是当有虚拟 机时，虚拟 CPU 第四行为物理内存信息Mem: 625344k total 物理内存的总量，单位 KB571504k used 已经使用的物理内存数量53840k free 空闲的物理内存数量，我们使用的是虚拟机，总 共只分配了 628MB 内存，所以只有 53MB 的空 闲内存了65800k buffers 缓冲的内存数量 第五行为交换分区（swap）信息Swap: 524280k total 交换分区（虚拟内存）的总大小0k used 已经使用的交互分区的大小524280k free 空闲交换分区的大小409280k cached 作为缓存的交互分区的大小 1.5 netstat 显示网络状态和端口占用信息 基本语法 12345678910111213netstat -anp | grep 进程号 （查看该进程网络信息）netstat –nlp | grep 端口号 （查看网络端口号占用情况）-a 显示所有正在监听（listen）和未监听的套接字（socket）-n 拒绝显示别名，能显示数字的全部转化成数字-l 仅列出在监听的服务状态-p 表示显示哪个进程在调用----------\\netstat -anp |grep sshd (通过进程号查看sshd进程的网络信息)netstat -nltp | grep 22(查看某端口号是否被占用) 1.6 crontab 服务管理 systemctl restart crond (重新启动 crond 服务) 1.7 crontab 定时任务设置 基本语法1234567891011121314151617181920212223242526272829303132crontab [选项]-e 编辑 crontab 定时任务-l 查询 crontab 任务-r 删除当前用户所有的 crontab 任务------crontab -e (进入 crontab 编辑界面。会打开作)* * * * * 执行的任务第一个“*” 一小时当中的第几分钟 0-59第二个“*” 一天当中的第几小时 0-23第三个“*” 一个月当中的第几天 1-31第四个“*” 一年当中的第几月 1-12第五个“*” 一周当中的星期几 0-7 （0 和 7 都 代 表 星 期日特殊符号* 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思， 代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的 8 点 0 分，12 点 0 分，16 点 0 分都执行一次命令- 代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周一到周六的凌晨 5 点 0 分执行命令*/n 代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔 10分钟就执行一遍命令特定时间执行命令45 22 * * * 命令 每天 22 点 45 分执行命令0 17 * * 1 命令 每周 1 的 17 点 0 分执行命令0 5 1,15 * * 命令 每月 1 号和 15 号的凌晨 5 点 0 分执行命令40 4 * * 1-5 命令 每周一到周五的凌晨 4 点 40 分执行命令*/10 4 * * * 命令 每天的凌晨 4 点，每隔 10 分钟执行一次命令0 0 1,15 * 1 命令 每月 1 号和 15 号，每周 1 的 0 点 0 分都会执行命令","categories":[],"tags":[]},{"title":"Linux学习-7","slug":"Linux学习-7","date":"2022-10-19T03:28:31.000Z","updated":"2022-10-19T06:25:14.274Z","comments":true,"path":"2022/10/19/Linux学习-7/","link":"","permalink":"http://example.com/2022/10/19/Linux%E5%AD%A6%E4%B9%A0-7/","excerpt":"","text":"1. Linux 磁盘查看和分区类1.1 du 查看文件和目录占用的磁盘空间du: disk usage 磁盘占用情况 基本语法123456789101112du 目录/文件 （显示目录下每个子目录的磁盘使用情况）-h 以较易阅读的 GBytes, MBytes, KBytes 等格式自行-a 不仅查看子目录大小，还要包括文件-c 显示所有的文件和子目录大小后，显示总和-s 只显示总和--max-depth=n 指定统计子目录的深度为第 n 层---------du -sh (查看当前用户主目录占用的磁盘空间大小) 1.2 df 查看磁盘空间使用情况 df: disk free 空余磁盘 基本语法1234567891011121314df 选项 （列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况）-h 以较易阅读的 GBytes, MBytes, KBytes 等格式自行显示df -h (查看磁盘使用情况)#### 1.3 lsblk 查看设备挂载情况- 基本语法lsblk （查看设备挂载情况）-f 查看详细的设备挂载情况，显示文件系统信息 1.4 mount/umount 挂载/卸载 对于Linux用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根目录、一个独立且唯一的文件结构。 Linux中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，要载入的那个分区将使它的存储空间在这个目录下获得 挂载前准备（必须要有光盘或者已经连接镜像文件） 基本语法 123456789101112131415161718192021222324252627mount [-t vfstype] [-o options] device dir （挂载设备）umount 设备文件名或挂载点 （卸载设备)-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有： 光盘或光盘镜像：iso9660 DOS fat16 文件系统：msdos Windows 9x fat32 文件系统：vfat Windows NT ntfs 文件系统：ntfs Mount Windows 文件网络共享：smbfs UNIX(LINUX) 文件网络共享：nfs-o options 主要用来描述设备或档案的挂接方式。常用的参数有： loop：用来把一个文件当成硬盘分区挂接上系统 ro：采用只读方式挂接设备 rw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集device 要挂接(mount)的设备dir 设备在系统上的挂接点(mount point)---------mkdir /mnt/cdrom (建立挂载点)mount -t iso9660 /dev/cdrom/mnt/cdrom (设备/dev/cdrom)(挂载光盘镜像文件)unmount /mnt/cdrom (卸载光盘镜像文件) 开机自动挂载 vi /etc/fstab 添加红框中内容，保存退出 1.5 fdisk 分区该命令必须在 root 用户下才能使用 基本语法12345678910111213141516171819fdisk -l （查看磁盘分区详情）fdisk 硬盘设备名 （对新增硬盘进行分区操作)-l 显示所有硬盘的分区列表（1）Linux 分区 Device：分区序列 Boot：引导 Start：从X磁柱开始 End：到Y磁柱结束 Blocks：容量 Id：分区类型ID System：分区类型（2）分区操作按键说明 m：显示命令列表 p：显示当前磁盘分区 n：新增分区 w：写入分区信息并退出 q：不保存分区信息直接退出","categories":[],"tags":[]},{"title":"Linux学习-6","slug":"Linux学习-6","date":"2022-10-18T08:08:01.000Z","updated":"2022-10-19T02:53:35.002Z","comments":true,"path":"2022/10/18/Linux学习-6/","link":"","permalink":"http://example.com/2022/10/18/Linux%E5%AD%A6%E4%B9%A0-6/","excerpt":"","text":"1. Linux 文件权限1.1 文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组 如果没有权限，就会出现减号[ - ]而已。从左至右用0-9这些数字来表示: 1234567890 首位表示类型在Linux中第一个字符代表这个文件是目录、文件或链接文件等等- 代表文件d 代表目录l 链接文档(link file)- --------第1-3位确定属主（该文件的所有者）拥有该文件的权限。---User第4-6位确定属组（所有者的同组用户）拥有该文件的权限，---Group第7-9位确定其他用户拥有该文件的权限 ---Other rwx 作用文件和目录的不同解释 12345678910作用到文件：[ r ]代表可读(read): 可以读取，查看[ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.[ x ]代表可执行(execute):可以被系统执行----- -----------作用到目录：[ r ]代表可读(read): 可以读取，ls查看目录内容[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录[ x ]代表可执行(execute):可以进入该目录 如果查看到是文件：链接数指的是硬链接个数 如果查看的是文件夹：链接数指的是子文件夹个数 1.2 chmod 改变权限 基本语法12345678910111213141516chmod [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] 文件或目录- --------chmod [mode=421]- -------u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和- -----r=4 w=2 x=1 rwx=4+2+1=7------------------------chmod u+x 3.txt （修改文件使其所属主用户具有执行权限）chmod g+x 3.txt (修改文件使其所属组用户具有执行权限)chmod u-x,o+x 3.txt (修改文件所属主用户执行权限,并使其他用户具有执行权限)chmod 777 3.txt (采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限)chmod -R 777 new/ (修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可执行权限) 1.3 chown 改变所有者 基本语法1234567chown [选项] [最终用户] [文件或目录] （改变文件或者目录的所有者）- -----R 递归操作-------------------chown newuser_1 3.txt (修改文件所有者)chown -R newuser_1 new/ (递归改变文件所有者和所有组) 1.4 chgrp 改变所属 基本语法123chgrp [最终用户组] [文件或目录] （改变文件或者目录的所属组）- ---------chgrp root 3.txt (修改文件的所属组) 2 搜索查找2.1 find 查找文件或者目录 find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端 基本语法 12345678910111213141516171819find [搜索范围] [选项]选项说明-name&lt;查询方式&gt; 按照指定的文件名查找模式查找文件-user&lt;用户名&gt; 查找属于指定用户名所有文件-size&lt;文件大小&gt; 按照指定的文件大小查找文件,单位为: b —— 块（512 字节） c —— 字节 w —— 字（2 字节） k —— 千字节 M —— 兆字节 G —— 吉字节------------------------------------------------------------find new/ -name &quot;*.txt&quot; (按文件名：根据名称查找/目录下的filename.txt文件)find new/ -user newuser(查找/opt目录下，用户名称为-user的文件)find /home -size +204800(在/home目录下查找大于200m的文件（+n 大于 -n小于 n等于) 2.2 locate 快速定位文件路径 locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。 Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。 基本语法 1234567locate 搜索文件- ----------由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库-- ---------------------updatedblocate tmp(查询文件夹) 2.3 grep 过滤查找及“|”管道符 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理 基本语法1234567grep 选项 查找内容 源文件-n 显示匹配行及行号- --------ls | grep -n test (查找某文件在第几行) 3. 压缩和解压类3.1 gzip/gunzip 压缩 基本语法 1234567891011gzip 文件 （压缩文件，只能将文件压缩为*.gz 文件）gunzip 文件.gz （解压缩文件命令）# -----------(1)只能压缩文件不能压缩目录（2）不保留原来的文件（3）同时多个文件会产生多个压缩包- ----------------gzip 3.txt (gzip压缩)gunzip 3.txt.gz (gunzip解压缩文件) 3.2 zip/unzip 压缩 基本语法 12345678910111213141516171819zip [选项] XXX.zip 将要压缩的内容 （压缩文件和目录的命令unzip [选项] XXX.zip （解压缩文件）-r 压缩目录-d&lt;目录&gt; 指定解压后文件的存放目录-----------zip 压缩命令在windows/linux都通用，可以压缩目录且保留源文件------zip new.zip 1.txt 2.txt(压缩 1.txt 和2.txt，压缩后的名称为new.zip)unzip new.zip(解压 new.zip)unzip new.zip -d /home (解压new.zip到指定目录-d) 3.3 tar 打包 基本语法 123456789101112131415161718192021tar [选项] XXX.tar.gz 将要打包进去的内容 （打包目录，压缩后的文件格式.tar.gz） -c 产生.tar 打包文件-v 显示详细信息-f 指定压缩后的文件名-z 打包同时压缩-x 解包.tar 文件-C 解压到指定目录- ------tar -zcvf new.tar.gz 1.txt 2.txt 3.txt(压缩多个文件)tar -zcvf mulu.tar.gz new/(压缩目录)tar -zxvf new.tar.gz(解压到当前目录)tar -zxvf new.tar.gz -C /home(解压到指定目录)","categories":[],"tags":[]},{"title":"Linux学习-5","slug":"Linux学习-5","date":"2022-10-18T06:51:17.000Z","updated":"2022-10-18T08:00:00.310Z","comments":true,"path":"2022/10/18/Linux学习-5/","link":"","permalink":"http://example.com/2022/10/18/Linux%E5%AD%A6%E4%B9%A0-5/","excerpt":"","text":"1.Linux 用户管理命令1.1 useradd 添加新用户 基本语法 12345678useradd 用户名 （添加新用户）useradd -g 组名 用户名 （添加新用户到某个组）-----------useradd newuserll /home/（添加一个用户） 1.2 passwd 设置用户密码 基本语法 123passwd 用户名 (设置用户密码)- ------------------passwd newuser (设置用户密码) 1.3 id 查看用户是否存在 基本语法 12id 用户名id newuser 1.4 cat /etc/passwd 查看创建了哪些用户cat /etc/passwd 1.5 su 切换用户su: swith user 切换用户 基本语法 1234567891011su 用户名称 （切换用户，只能获得用户的执行权限，不能获得环境变量）su - 用户名称 （切换到用户并获得该用户的环境变量及执行权限）-----------su newuserecho $PATHexit --------su -newuserecho $PATH 1.6 userdel 删除用户 基本语法 12345678910111213userdel 用户名 （删除用户但保存用户主目录）userdel -r 用户名 （用户和用户主目录，都删除)------r 删除用户的同时，删除与用户相关的所有文件- -----userdel newuserll /home/(除用户但保存用户主目录)userdel -r newuserll /home/(删除用户和用户主目录，都删除) 1.7 who 查看登录用户信息 基本语法 12whoami （显示自身用户名称）who am i （显示登录用户的用户名以及登陆时间 1.8 sudo 设置普通用户具有 root 权限 步骤 12345678910111213useradd newuser_1passwd newuser_1(添加 newuser_1 用户，并对其设置密码)vi /etc/sudoers(修改 /etc/sudoers 文件，找到下面一行(91 行)，在 root 下面添加一行)//## Allow root to run any commands anywhereroot ALL=(ALL) ALLatguigu ALL=(ALL) ALL(或者配置成采用 sudo 命令时，不需要输入密码)//## Allow root to run any commands anywhereroot ALL=(ALL) ALLatguigu ALL=(ALL) NOPASSWD:ALL修改完毕，现在可以用 newuser_1 帐号登录，然后用命令 sudo ，即可获得 root 权限进行操作 1.9 usermod 修改 基本语法 123456usermod -g 用户组-- 选项说明---g 修改用户的初始登录组，给定的组必须存在。默认组 id 是 1usermod -g root newuser_1(将用户加入到用户组) 2. 用户组管理命令每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新 2.1 groupadd 新增组 基本语法123groupadd 组名groupadd newgroup (添加一个newgroup组) 2.2 groupdel 删除 基本语法1234groupdel 组名groupdel newgroup(删除newgroup组) 2.3 groupmod 修改组 基本语法1234groupmod -n 新组名 老组名-n&lt;新组名&gt; 指定工作组的新组名groupmod -n newgroup newgroup_1 2.4 cat /etc/group 查看创建了哪些组 cat /etc/group","categories":[],"tags":[]},{"title":"Linux学习-4","slug":"Linux学习-4","date":"2022-10-17T10:09:46.000Z","updated":"2022-10-18T08:04:39.113Z","comments":true,"path":"2022/10/17/Linux学习-4/","link":"","permalink":"http://example.com/2022/10/17/Linux%E5%AD%A6%E4%B9%A0-4/","excerpt":"","text":"//##(28) Linux 常用基本命令 Centos7 默认shell工具是bash 还有tcsh（不是默认的） 12ls -l /bin |grep sh详细查看bin目录下 带sh的命令 1 帮助命令1.1 man获得帮助信息 基本语法 man [命令或配置文件] (获取帮助信息) 信息 功能 NAME 命令的名称和单行描述 SYNOPSIS 怎样使用命令 DESCRIPTION 命令功能的深入讨论 EXAMPLES 怎么使用命令的例子 SEE ALSO 相关主题（手册页） 12man ls name(查看ls帮助信息) 1.2 help 获得shell内置命令的帮助信息一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）命令”；相应的其它命令被称为“外部命令” 基本语法 help 命令 （获得shell内置命令的帮助信息）help cd (查看cd命令的帮助信息) 常用快捷键1234ctrl+c (停止进程)ctrl+i 清屏tab 提示上下键 查找执行过的命令 2 文件目录2.1 pwd 显示当前工作目录的绝对路径pwd 全称（print working directory） 打印工作目录 1pwd (显示当前工作目录的绝对路径) 2.2 ls列出目录的内容ls (list) 列出目录内容 基本语法 ls [选项] [目录或是文件] 选项说明 -a (全部文件，连通隐藏（开头为.的文件）一起列出来（常用）) -l (长数据串列出，包含 文件的属性和权限等等数据) 显示说明 每行列出的信息依次是： 文件类型与权限 链接数 文件属主 文件属组 文件大小用byte来表示 建立或最近修改的时间 名字 12ls -al (查看当前目录的所有内容信息) 2.3 cd 切换目录cd ： Change Directory 切换路径 基本语法 cd [参数] 参数说明 参数 功能 cd 绝对路径 切换路径 cd 相对路径 切换路径 cd ~ 或者 cd 回到自己的家目录 cd - 回到上一次所在的目录 cd .. 回到当前目录的上一级目录 cd -P 跳转到实际物理路径，而非快捷方式路径 12345cd /root/ (使用绝对路径切换到root目录)cd 公共的/ （使用相对路径切换到“公共的”目录）cd ~ （表示回到自己的家目录）cd - (回到上一次所在目录)cd .. (表示回到当前目录的上一级目录) 2.4 mkdir 创建一个新的目录mkdir:Make directory 建立目录 基本语法 mkdir [选项] 选项说明 -p 创建多层目录 1234567mkdir yicengmkdir yiceng/erceng(创建一个目录)mkdir -p yiceng/erceng/sanceng(创建一个多级目录) 2.5 rmdir 删除一个空的rmdir:Remove directory 移除目录 基本语法 rmdir 要删除的空目录 12rmdir yiceng/erceng/sanceng(删除一个空的文件夹) 2.6 touch 创建空文件 基本语法 touch 文件名称 1touch yiceng/erceng/sanceng/3.txt 2.7 cp 复制文件或目录 基本语法 cp [选项] source dest （复制source文件到dest） 选项说明 -r 递归复制整个文件夹 参数说明 source 源文件 dest 目标文件 123\\cp (强制覆盖不提示的方法)cp yiceng/erceng/sanceng/3.txt dest/new/ (复制文件)cp -r yiceng/erceng dest/new_1 (递归复制整个文件夹) 2.8 8 rm 删除文件或目录 基本语法 rm [选项] deleteFile （递归删除目录中所有内容) 选项说明 123456-r (递归删除目录中所有内容)-f (强制执行删除操作，而不提示用于进行确认)-v (显示指令的详细执行过程) --------------------------------rm yiceng/erceng/sanceng/3.txt (删除目录中的内容)rm -rf dest/new/ (递归删除目录中所有内容) 2.9 mv 移动文件与目录或重命名 基本语法 mv oldNameFile newNameFile （功能描述：重命名） mv /temp/movefile /targetFolder （功能描述：移动文件） 12mv yiceng/erceng/sanceng/3.txt yiceng/erceng/sanceng/3_1.txt (重命名)mv yiceng/dest/3.txt /new/new_1/ (移动文件) 2.10 cat 查看文件内容查看文件内容，从第一行开始显示 基本语法 cat [选项] 要查看的文件 选项说明 -n 显示所有行的行号，包括空行 一般查看比较小的文件，一屏幕能显示全的 cat -n 3.txt (查看文件内容并显示行号) 2.11 more 文件内容分屏查看器more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键 基本语法 more 要查看的 操作说明 1234567空白键 (space) 代表向下翻一页；Enter 代表向下翻『一行』；q 代表立刻离开 more ，不再显示该文件内容。Ctrl+F 向下滚动一屏Ctrl+B 返回上一屏= 输出当前行的行号:f 输出文件名和当前行的行号 2.12 less 分屏显示文件内容less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率 基本语法 less 要查看的文件 操作说明 123456空白键 向下翻动一页；[pagedown] 向下翻动一页[pageup] 向上翻动一页；/字串 向下搜寻『字串』的功能；n：向下查找；N：向上查找；?字串 向上搜寻『字串』的功能；n：向上查找；N：向下查找；q 离开 less 用SecureCRT时[pagedown]和[pageup]可能会出现无法识别的问题 1less 3.txt (less 查看文件) 2.13 echo echo 输出内容到控制台 基本语法 echo [选项] 选项 -e 支持反斜线控制的字符转换 123456\\\\ 输出\\本身\\n 换行符\\t 制表符，也就是 Tab 键 --------------echo &quot;yiceng/3.txt&quot;echo -e &quot;yiceng/3.txt&quot; 2.14 head 显示文件头部内容head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容 基本语法 head 文件 （查看文件头10行内容） head -n 5 文件 （查看文件头5行内容，5可以是任意行数 选项说明 -n&lt;行数&gt; 指定显示头部内容的行数 1head -n 2 3.txt 2.15 tail 输出文件尾部内容tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容 基本语法 123tail 文件 （查看文件尾部10行内容）tail -n 5 文件 （查看文件尾部5行内容，5可以是任意行数）tail -f 文件 （实时追踪该文档的所有更新) 选项说明 123456-n&lt;行数&gt; 输出文件尾部 n 行内容-f 显示文件最新追加的内容，监视文件变化 --------------------------------- tail -n 3 3.txt (查看文件尾 3行内) tail -f 3.txt (实时追踪该档的所有更新) 2.16 &gt; 输出重定向和 &gt;&gt; 追加 （重点） 基本语法123456789ls -l &gt; 文件 （列表的内容写入文件 a.txt 中（覆盖写）ls -al &gt;&gt; 文件 （功能描述：列表的内容追加到文件 aa.txt 的末尾）cat 文件 1 &gt; 文件 2 （功能描述：将文件 1 的内容覆盖到文件 2）echo “内容” &gt;&gt; 文件-------------------ls -l&gt;3.txt (将 ls 查看信息写入到文件中)ls -l&gt;&gt;3.txt (将 ls 查看信息追)echo hello&gt;&gt;3.txt (采用 echo 将 hello 单词追加到文件中) 2.17 ln 软链 软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放了链接其他文件的路径 基本语法 ln -s [原文件或目录] [软链接名] （给原文件创建一个软链接） 12345678910111213删除软链接： rm -rf 软链接名，而不是 rm -rf 软链接名/如果使用 rm -rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉查询：通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向-------------------ln -s xiyou/3.txt ./new_1ll(查看软连接)rm -rf new_1 (删除软连接)ln -s source/de/ ./new_1cd -P new_1/ (进入软连接实际物理路径) 2.18 history 查看已经执行过历史命令 基本语法 history （查看已经执行过历史命令） 1history (查看已经执行过的历史命令) 3 时间日期类3.1 date 显示当前时间 基本语法 1234567891011date [OPTION]... [+FORMAT]选项说明-d&lt;时间字符串&gt; 显示指定的“时间字符串”表示的时间，而非当前时间-s&lt;日期时间&gt; 设置系统日期时间&lt;+日期时间格式&gt; 指定显示时使用的日期时间格式 -------------------（1）date （显示当前时间）（2）date +%Y （显示当前年份）（3）date +%m （显示当前月份）（4）date +%d （显示当前是哪一天）（5）date &quot;+%Y-%m-%d %H:%M:%S&quot; （显示年月日时分秒） 3.2 date 显示非当前时间 基本语法 12（1）date -d &#x27;1 days ago&#x27; （显示前一天时间）（2）date -d &#x27;-1 days ago&#x27; （显示明天时间 3.3 date 设置系统时间 基本语法12345date -s 字符串时间----------date -s &quot;2017-06-19 20:52（设置系统时间） 3.4 cal 查看日历 基本语法 cal [选项] （不加选项，显示本月日历) 选项说明1234具体某一年 显示这一年的日历cal (查看当前月的日历)cal 2017 (查看 2017 年的日历)","categories":[],"tags":[]},{"title":"Linux学习-3","slug":"Linux学习-3","date":"2022-10-17T06:45:22.000Z","updated":"2022-10-17T10:08:25.609Z","comments":true,"path":"2022/10/17/Linux学习-3/","link":"","permalink":"http://example.com/2022/10/17/Linux%E5%AD%A6%E4%B9%A0-3/","excerpt":"","text":"||win键+空格键 切换输入法 系统管理1 Linux中的进程和服务计算机中，一个正在执行的程序或命令，被叫“进程”（PID）、启动之后一直存在，常驻内存的进程，一般被称为服务 1.1 service服务管理（CentOS6 版本） 基本语法service 服务名 start| stop | restart |status（censtOS7 已经不使用） 查看服务的方法： /etc/init.d/服务名 pwd 查看当前路径 ls -al 查看文件 1234567(1) 查看网络服务的状态service network status(2) 停止网络服务service network stop(3) 启动网络服务 service network start(4) service network restart 1.2 chkconfig 设置后台服务的自启配置（CentOS 6版本） 基本语法 12345chkconfig --list 查看chkconfig (查看所有服务器自启配置)chkconfig 服务名 off （关掉指定服务的自动启动）chkconfig 服务名 on (开启指定服务的自动启动)chkconfig 服务名 --list (查看服务开机启动状态) 开启/关闭 network (网络)服务的自动启动 12chkconfig network onchkconfig network off 开启/关闭 network 服务指定级别的自动启动 12chkconfig --level 指定级别（0-5） network onchkconfig --level 指定级别（0-5） network off 1.3 systemctl(CentOS 7 版本) 基本语法systemctl start | stop| restart |status 服务名 查看方法 123# /usr/lib/systemd/system# pwd# ls -all 防火墙 12345678(1)查看防火墙服务的状态systemctl status firewalled(2)停止防火墙服务systemctl stop firewalled(3)启动防火墙服务systemctl start firewalled(4)重启防火墙服务systemctl restart firewalled 1.4 systemctl 设置后台服务的自启配置 基本语法 123456systemctl list-unit-files (查看服务开机启动状态)systemctl disable service_name (关掉指定服务的自动启动)systemctl enable service_name (开启指定服务的自动启动)--开启/关闭iptables（防火墙）服务的自动启动systemctl enable firewalld.servicesystemctl disable firewalld.service 1.5 系统的运行级别 运行级别 12345678910查看默认级别 vi/etc/inittabLinux系统有7种运行级别：常用的级别是3和5运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆(安全模式)运行级别2：多用户状态（没有NFS），不支持网络运行级别3：完全的多用户状态（NFS）,登陆后进入控制台命令模式（黑框框）运行级别4：系统未使用，保留（一般不用）运行级别5：X11控制台，登陆后进入图像GUI模式运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 CentOS7 的运行级别简化为： 1234567multi-user.target 等价于原运行级别3 （多用户有网， 无图形界面）graphical.target 等价于原运行级别5 （多用户有网,有图形界面）systemctl get-default（查看当前运行级别）修改当前运行级别systemctl set-default TARGET.target (这里TARGET取multi-user 或者 graphical) 1.6 关机重启命令 基本语法 – sync (将数据由内存同步到硬盘中) –halt （停机，关闭系统，但不断电） –poweroff（关机，断电） –reboot（重启 等同于 shutdown -r now） shutdown [选项] 时间 选项 功能 -H 相当 –halt，停机 -r -r=reboot 重启 now 立刻关机 时间 等待多久后关机 Linux 系统中为了提高磁盘的读写效率，对磁盘采取了 “预读迟写”操作方式。 当用户保存文件时，Linux 核心并不一定立即将保存数据写入物理磁盘中，而是将数据保存在缓冲区中，等缓冲区满时再写入磁盘，这种方式可以极大的提高磁盘写入数据的效率。 但是，也带来了安全隐患，如果数据还未写入磁盘时，系统掉电或者其他严重问题出现，则将导致数据丢失。 使用 sync 指令可以立即将缓冲区的数据写入磁盘。 123456789101112131415# sync (将数据由内存同步到硬盘中)# reboot(重启)# halt(停机，不停电)# shutdown -h 1 &#x27;This server will shutdown after 1 mins&#x27;(计算机将在1分钟后关机，并且会显示在登陆用户的当前屏幕)# shutdown -h now （立马关机，等同于poweroff# shutdown -r now (系统立马重启)# shutdown -c (取消关机)","categories":[],"tags":[]},{"title":"Linux学习-2","slug":"Linux学习-2","date":"2022-10-17T01:50:06.000Z","updated":"2022-10-17T02:54:33.771Z","comments":true,"path":"2022/10/17/Linux学习-2/","link":"","permalink":"http://example.com/2022/10/17/Linux%E5%AD%A6%E4%B9%A0-2/","excerpt":"","text":"vi/vim 编辑器VI是Unix操作系统和类Unix系统中最通用的文本编辑器VIM编辑器是从VI发展来的一个性能更为强大的文本编辑器。VIM与VI编辑器完全兼容 一般模式以 vi 打开一个档案就直接进入一般模式了（这是默认的模式）。一般模式中， 可使用『上下左右』按键来移动光标，可使用『删除字符』或『删除整行』来处理档案内容， 也可使用『复制、粘贴』来处理文件数据 常用语法 语法 功能描述 yy 复制光标当前一行 y 数字 y 复制一段 （从第几行到第几行） p 箭头移动到目的行粘贴 u 撤销上一步 dd 删除光标当前行 d 数字 d 删除光标（含）后多少行 x 剪切一个字母，相当于del X（大写） 剪切一个字母，相当于BackSpace yw 复制一个词 dw 删除一个词 shift+6（^） 移动到行头 shift+4($) 移动到行尾 1+shift+g 移动到页头，数字 shitf+g 移动到页尾 数字+shift+g 移动到目标行 编辑模式一般模式中可以进行删除、复制、粘贴等的动作，但是却无法编辑文件内容的！在按下『i, I, o, O, a, A』等任何一个字母之后才会进入编辑模式。通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或REPLACE』的字样，此时才能进行编辑。而如果要回到一般模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。 常用语法 语法 功能描述 i 当前光标后 a 当前光标前 o 当前光标行的下一行 I 光标所在行最前 A 光标所在行的最后 O 当前光标行的上一行 按『Esc』键 退出编辑模式，之后所在的模式为一般模式。 指令模式在一般模式当中，输入『 : / ?』3个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中， 可以提供『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 等 常用语法 语法 功能描述 :w 保存 :q 退出 :! 强制执行 /要查询的词 n查找下一个，N往上查找 :noth 取消高亮显示 :set nu 显示行号 :set nonu 关闭行号 :%s/old/new/g 替换内容 /g 替换匹配到的所有内容 模式转化","categories":[],"tags":[{"name":"自学","slug":"自学","permalink":"http://example.com/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"Linux学习_1","slug":"Linux学习-1","date":"2022-09-28T11:24:38.000Z","updated":"2022-10-17T01:44:09.334Z","comments":true,"path":"2022/09/28/Linux学习-1/","link":"","permalink":"http://example.com/2022/09/28/Linux%E5%AD%A6%E4%B9%A0-1/","excerpt":"","text":"学习目录 基础 linux安装 文件与目录结构 VI/VIM编辑器 网络配置 系统管理 远程登录 实战 文件目录类 时间日期类 用户管理类 文件权限类 磁盘分区类 进程线程类 扩展 软件包管理 克隆虚拟机 shell编程 1基于Centos7.9 Linux是一个操作系统（os）BSD（伯克利分校）（FreeBSD）（1993） Linux 发行版 Red Hat(性能强，稳定)（服务器系统首选） Red Hat Enterprise Linux 文件目录 /bin 是Binary的缩写，此目录存放最经常使用的命令 /sbin s就是Super User 存放系统管理员使用的系统管理程序 /home 存放普通用户的主目录，在liunx中每个用户都有一个自己的目录，一般该目录是以用户的账号命名的 /root 该目录为系统管理员，也称超级权限者的用户主目录 /lib 系统开机所需要最基本的动态连接共享库，类型于window系统的dll文件，几乎所有的应用程序都需要这些共享库 /lost+found 一般情况下这个目录是空的，当系统非法关机后，该目录就会存放一些文件 /etc 所有的系统管理所需要的配置文件和子目录 /usr 用户的很多应用程序和文件都放在这个目录下，类似于windows下program files目录 /boot 存放的是启动Liunx时使用的一些核心文件，包括一些连接文件以及镜像文件（自己的安装别放在这里） /proc 这个目录为虚拟目录，是系统内存的映射，可以通过直接访问这个目录来获取系统的信息 /srv service 缩写 该目录存放一些服务启动后需要提取的数据 /sys 这个Liunx2.6内核的一个很大变化，该目录下安装2.6内核中新出现的一个文件系统sysfs /tmp 存放一些临时文件 /dev 类似windows的设备管理器，把所有的硬件用文件的形式存储 /media(CentOS6) liunx系统会自动识别一些设备，如U盘，光驱等等，当识别后，liunx会把识别的设备挂载到这个目录下CentOS7 迁移到/run/media /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容 /opt 这个给主机额外安装软件所存放的目录，如安装一个mysql就可以放到这个目录下，默认为空 /var 目录中存放不断扩充的东西，习惯性将那些经常被修改的目录放在其中。包括各种日志文件","categories":[],"tags":[{"name":"自学","slug":"自学","permalink":"http://example.com/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"Markdowm学习笔记","slug":"Markdowm学习笔记","date":"2022-09-28T06:31:30.000Z","updated":"2022-09-28T10:16:01.060Z","comments":true,"path":"2022/09/28/Markdowm学习笔记/","link":"","permalink":"http://example.com/2022/09/28/Markdowm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"MarkDowm 基础1. 标题#号的个数代表标题的几级 一级标题使用一个#二级标题使用二个#号最多支持六级标题 2. 文字删除线(~~ )(前后各两个波浪号)~~(没啥用)~~ 删除线 ~~ 3. 斜体 文字(前后各一个*号) 4.加粗文字(前后各两个*号加粗) 5.斜体和加粗文字(前后三个*号) 6.下划线HTML语法文字(前后闭合)== == 7. 高亮1==***文字***==(vscode好像不能用) 8. 下标1H~2-o~2(~下标)（(vscode好像不能用)） 9.上标123456789101112131415平方米 m^2^（(vscode好像不能用)）````## 10.表情符号Emoji支持表情符号，可以使用系统默认的Emoji(windows不支持)也可以用图片的表情输出: 将出现智能提示## 11.表格使用 `|` 来分隔不同的单元格，使用`-`来分隔表头和其它行```markdownname | price--- | ---fried chicken | 19cola | 5 为了使Markdown更为清晰，| 和-两侧需要至少有一个空格（最左侧和右侧| 外就不需要了） name price friedchicken 19 cola 5 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用|来标记单元格边界，在表头下方的分隔线标记中加入:,即可标记下方的单元格内容的对齐方式： 1234|name | price ||:------------| :----: ||friedchicken | 19 ||cola | 5 | name price friedchicken 19 cola 5 12. 引用 “后悔”（估计用不上） 13. 列表无序列表 符号空格）123* 可以+ 可以- 可以 无序列表 无序 无序 有序列表 数字. 空格1231. 有序列表以数字和 . 开始2. 数字的序列并不影响生成的列表序列3. 但仍然推荐按照自然顺序（1,2,3...）编写 有序列表以数字和 . 开始 数字的序列并不影响生成的列表序列 但仍然推荐按照自然顺序（1,2,3…）编写 14 代码块代码块1```语言名称 123456789101112131415161718#include&lt;iostream&gt;class Solution&#123; public: int x,y; void add(int x,const );&#125;;void Solution::add(int x,int y)&#123; std::cout&lt;&lt;a+b&lt;&lt;std::endl;&#125;int main()&#123; Solution a; const int a=10,b=12; a.add(a,b); return &#125; 行内代码123也可以通过``插入行内代码（` 是 `Tab` 键上边，数字`1`左侧的按键） 15. 分隔线可以在一行中使用三个或更多的*,- 或者_来添加分隔线 123***------__________ 16. 跳转格式为[line text][link] 1[帮助文档][https://www.baidu.com] 17.自动连接使用&lt;&gt;包括的URL或邮箱地址会自动转换为超链接 12&lt;https://www.baidu.com&gt;&lt;123@gmail.com&gt; htpps:www.baidu.com &#x31;&#50;&#51;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#111;&#x6d; 18.图片123![图像名](图片地址或图片本地存储的路基)![美女](https://images.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E5%8A%A8%E6%BC%AB&amp;step_word=&amp;hs=0&amp;pn=27&amp;spn=0&amp;di=7136437450519347201&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;istype=2&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=-1&amp;cs=3820124795%2C828804674&amp;os=305612968%2C2325005128&amp;simid=3820124795%2C828804674&amp;adpicid=0&amp;lpn=0&amp;ln=1918&amp;fr=&amp;fmq=1664353996706_R&amp;fm=result&amp;ic=0&amp;s=undefined&amp;hd=&amp;latest=&amp;copyright=&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=https%3A%2F%2Fgimg2.baidu.com%2Fimage_search%2Fsrc%3Dhttp%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2020-07-15%2F5f0ecbb7a61e2.jpg%26refer%3Dhttp%3A%2F%2Fpic1.win4000.com%26app%3D2002%26size%3Df9999%2C10000%26q%3Da80%26n%3D0%26g%3D0n%26fmt%3Dauto%3Fsec%3D1666946001%26t%3D66b028325c022ad6711ff9ba6413302b&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Botg9aaa_z%26e3Bv54AzdH3Fowssrwrj6_1jpwts_80aln9_n_z%26e3Bip4s&amp;gsm=1d0000000000001d&amp;rpstart=0&amp;rpnum=0&amp;islist=&amp;querylist=&amp;nojc=undefined.jpg) 添加图片时，先安装 1npm install https://github.com/CodeFalling/hexo-asset-image --save 使用 hexo n 文件夹名（md文件同名，把图片文件都放入该文件下） 1![txt](3.jpg) 19.Markdowm画图（需要沟选扩展语法）","categories":[],"tags":[{"name":"自学","slug":"自学","permalink":"http://example.com/tags/%E8%87%AA%E5%AD%A6/"}]},{"title":"test_git","slug":"test-git","date":"2022-09-26T09:39:52.000Z","updated":"2022-10-21T07:58:53.444Z","comments":true,"path":"2022/09/26/test-git/","link":"","permalink":"http://example.com/2022/09/26/test-git/","excerpt":"","text":"开源众包官网 电鸭社区官方网站 码市官方网站 Toptal 官方网站 程序员客栈官网 AngelList 官方网站 猪八戒官网","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-26T06:54:35.497Z","updated":"2022-09-23T09:30:32.569Z","comments":true,"path":"2022/09/26/hello-world/","link":"","permalink":"http://example.com/2022/09/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"eigen","slug":"eigen","permalink":"http://example.com/tags/eigen/"},{"name":"自学","slug":"自学","permalink":"http://example.com/tags/%E8%87%AA%E5%AD%A6/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]}